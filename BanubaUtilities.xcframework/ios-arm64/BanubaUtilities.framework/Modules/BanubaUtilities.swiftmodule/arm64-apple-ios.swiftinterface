// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.2 effective-5.10 (swiftlang-6.0.2.1.2 clang-1600.0.26.4)
// swift-module-flags: -target arm64-apple-ios15.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name BanubaUtilities
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import AVFoundation
import AVKit
import Accelerate
@_exported import BanubaUtilities
import CarPlay
import CloudKit
import Combine
import CommonCrypto
import CoreGraphics
import CoreImage
import CoreMedia
import CryptoKit
import Foundation
import Foundation/*.NSRecursiveLock*/
import ImageIO
import MobileCoreServices
import Photos
import PhotosUI
import Swift
import SwiftUI
import SystemConfiguration
import UIKit
import UniformTypeIdentifiers
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os.log
import os
public protocol ImageButtonConfigurationProtocol {
  var imageConfiguration: any BanubaUtilities.ImageConfigurationProtocol { get set }
  var selectedImageConfiguration: (any BanubaUtilities.ImageConfigurationProtocol)? { get set }
}
public struct BanubaImageButtonConfiguration : BanubaUtilities.ImageButtonConfigurationProtocol {
  public var imageConfiguration: any BanubaUtilities.ImageConfigurationProtocol
  public var selectedImageConfiguration: (any BanubaUtilities.ImageConfigurationProtocol)?
  public init(imageConfiguration: any BanubaUtilities.ImageConfigurationProtocol, selectedImageConfiguration: (any BanubaUtilities.ImageConfigurationProtocol)? = nil)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class AlertViewController : UIKit.UIViewController, BanubaUtilities.NibLoadable {
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak final public var contextView: UIKit.UIView!
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak final public var backgroundView: UIKit.UIView!
  @_Concurrency.MainActor @preconcurrency @objc override final public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  public enum AlertType {
    case info
    case selection(_: Swift.String?, _: Swift.String?)
    case reset(_: Swift.String?, _: Swift.String?, _: Swift.String?)
    case startOver(_: Swift.String, _: Swift.String, _: Swift.String)
    case missedPermission
    case recordingWithoutMask
    case destructive(_: Swift.String, _: Swift.String)
  }
  public enum ButtonType {
    case agreeButton
    case refuseButton
    case additionalButton
    public static func == (a: BanubaUtilities.AlertViewController.ButtonType, b: BanubaUtilities.AlertViewController.ButtonType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency final public var titleText: Swift.String? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var messageText: Swift.String? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var alertType: BanubaUtilities.AlertViewController.AlertType? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var configuration: BanubaUtilities.AlertViewConfiguration?
  @_Concurrency.MainActor @preconcurrency final public var actionHandler: ((Swift.Bool, BanubaUtilities.AlertViewController.ButtonType) -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency @objc override final public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public struct AudioContext {
  public static let averagePeak: Swift.Float
  public static func averagePowers(audioFileURL: Foundation.URL, forChannel channelNumber: Swift.Int, compositionStart: Foundation.TimeInterval, compositionEnd: Foundation.TimeInterval?, duration: Foundation.TimeInterval, numberOfPeaks: Swift.Int, completionHandler: @escaping (_ success: [Swift.Float]) -> ())
  public static func amplitudeSamples(audioFileURL: Foundation.URL, numberOfSamples: Swift.Int) -> [Swift.Float]
  public static func amplitudeSamples(audioFileURL: Foundation.URL, numberOfSamples: Swift.Int, completionHandler: @escaping (_ success: [Swift.Float]) -> ())
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func withLatestFrom<Other, Result>(_ other: Other, resultSelector: @escaping (Self.Output, Other.Output) -> Result) -> Combine.Publishers.WithLatestFrom<Self, Other, Result> where Other : Combine.Publisher, Self.Failure == Other.Failure
  public func withLatestFrom<Other, Other1, Result>(_ other: Other, _ other1: Other1, resultSelector: @escaping (Self.Output, (Other.Output, Other1.Output)) -> Result) -> Combine.Publishers.WithLatestFrom<Self, Combine.AnyPublisher<(Other.Output, Other1.Output), Self.Failure>, Result> where Other : Combine.Publisher, Other1 : Combine.Publisher, Self.Failure == Other.Failure, Other.Failure == Other1.Failure
  public func withLatestFrom<Other, Other1, Other2, Result>(_ other: Other, _ other1: Other1, _ other2: Other2, resultSelector: @escaping (Self.Output, (Other.Output, Other1.Output, Other2.Output)) -> Result) -> Combine.Publishers.WithLatestFrom<Self, Combine.AnyPublisher<(Other.Output, Other1.Output, Other2.Output), Self.Failure>, Result> where Other : Combine.Publisher, Other1 : Combine.Publisher, Other2 : Combine.Publisher, Self.Failure == Other.Failure, Other.Failure == Other1.Failure, Other1.Failure == Other2.Failure
  public func withLatestFrom<Other>(_ other: Other) -> Combine.Publishers.WithLatestFrom<Self, Other, Other.Output> where Other : Combine.Publisher, Self.Failure == Other.Failure
  public func withLatestFrom<Other, Other1>(_ other: Other, _ other1: Other1) -> Combine.Publishers.WithLatestFrom<Self, Combine.AnyPublisher<(Other.Output, Other1.Output), Self.Failure>, (Other.Output, Other1.Output)> where Other : Combine.Publisher, Other1 : Combine.Publisher, Self.Failure == Other.Failure, Other.Failure == Other1.Failure
  public func withLatestFrom<Other, Other1, Other2>(_ other: Other, _ other1: Other1, _ other2: Other2) -> Combine.Publishers.WithLatestFrom<Self, Combine.AnyPublisher<(Other.Output, Other1.Output, Other2.Output), Self.Failure>, (Other.Output, Other1.Output, Other2.Output)> where Other : Combine.Publisher, Other1 : Combine.Publisher, Other2 : Combine.Publisher, Self.Failure == Other.Failure, Other.Failure == Other1.Failure, Other1.Failure == Other2.Failure
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publishers {
  public struct WithLatestFrom<Upstream, Other, Output> : Combine.Publisher where Upstream : Combine.Publisher, Other : Combine.Publisher, Upstream.Failure == Other.Failure {
    public typealias Failure = Upstream.Failure
    public typealias ResultSelector = (Upstream.Output, Other.Output) -> Output
    public func receive<S>(subscriber: S) where Output == S.Input, S : Combine.Subscriber, Other.Failure == S.Failure
  }
}
@objc public class TextButtonConfiguration : ObjectiveC.NSObject {
  public var style: BanubaUtilities.TextConfiguration
  public var text: Swift.String?
  public init(style: BanubaUtilities.TextConfiguration, text: Swift.String? = nil)
  @objc deinit
}
public enum AspectRatio : Swift.UInt8, Swift.Codable {
  case original
  case aspect16x9
  case aspect9x16
  case aspect4x3
  case aspect4x5
  public func getVideoAspectRatio(withVideoSize videoSize: CoreFoundation.CGSize? = nil) -> CoreFoundation.CGFloat
  public init(videoAspectRatio: CoreFoundation.CGFloat)
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension CoreFoundation.CGRect {
  public func getCenter() -> CoreFoundation.CGPoint
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class SlideInPresentationManager : ObjectiveC.NSObject, UIKit.UIViewControllerTransitioningDelegate {
  @_Concurrency.MainActor @preconcurrency public var backgroundViewInteractionHandler: (() -> Swift.Void)? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public init(coverPercentage: CoreFoundation.CGFloat, panToDismiss: Swift.Bool, backgroundViewStyle: BanubaUtilities.BackgroundViewStyle, dismissOnTapByBackgroundView: Swift.Bool = false, transitionDuration: Foundation.TimeInterval = 0.3)
  @_Concurrency.MainActor @preconcurrency public init(coverHeight: CoreFoundation.CGFloat, panToDismiss: Swift.Bool, backgroundViewStyle: BanubaUtilities.BackgroundViewStyle, dismissOnTapByBackgroundView: Swift.Bool, transitionDuration: Foundation.TimeInterval = 0.3)
  @_Concurrency.MainActor @preconcurrency @objc convenience override dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc public func presentationController(forPresented presented: UIKit.UIViewController, presenting: UIKit.UIViewController?, source: UIKit.UIViewController) -> UIKit.UIPresentationController?
  @_Concurrency.MainActor @preconcurrency @objc public func animationController(forPresented presented: UIKit.UIViewController, presenting: UIKit.UIViewController, source: UIKit.UIViewController) -> (any UIKit.UIViewControllerAnimatedTransitioning)?
  @_Concurrency.MainActor @preconcurrency @objc public func animationController(forDismissed dismissed: UIKit.UIViewController) -> (any UIKit.UIViewControllerAnimatedTransitioning)?
  @_Concurrency.MainActor @preconcurrency @objc public func interactionControllerForPresentation(using animator: any UIKit.UIViewControllerAnimatedTransitioning) -> (any UIKit.UIViewControllerInteractiveTransitioning)?
  @_Concurrency.MainActor @preconcurrency @objc public func interactionControllerForDismissal(using animator: any UIKit.UIViewControllerAnimatedTransitioning) -> (any UIKit.UIViewControllerInteractiveTransitioning)?
  @objc deinit
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor @preconcurrency open class BaseTrackSelectionViewController : UIKit.UINavigationController, BanubaUtilities.TrackSelectionViewController {
  @_Concurrency.MainActor @preconcurrency weak public var trackSelectionDelegate: (any BanubaUtilities.TrackSelectionViewControllerDelegate)?
  @available(iOS 5.0, *)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(navigationBarClass: Swift.AnyClass?, toolbarClass: Swift.AnyClass?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(rootViewController: UIKit.UIViewController)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
public protocol TrackSelectionViewControllerDelegate : AnyObject {
  func trackSelectionViewController(viewController: any BanubaUtilities.TrackSelectionViewController, didSelectFile url: Foundation.URL, coverURL: Foundation.URL?, timeRange: CoreMedia.CMTimeRange?, isEditable: Swift.Bool, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID)
  func trackSelectionViewControllerDidCancel(viewController: any BanubaUtilities.TrackSelectionViewController)
  func trackSelectionViewControllerDiscardCurrentTrack(viewController: any BanubaUtilities.TrackSelectionViewController)
}
extension BanubaUtilities.TrackSelectionViewControllerDelegate {
  public func trackSelectionViewController(viewController: any BanubaUtilities.TrackSelectionViewController, didSelectFile url: Foundation.URL, coverURL: Foundation.URL? = nil, timeRange: CoreMedia.CMTimeRange? = nil, isEditable: Swift.Bool, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID)
}
extension BanubaUtilities.TrackSelectionViewControllerDelegate {
  public func trackSelectionViewControllerDiscardCurrentTrack(viewController: any BanubaUtilities.TrackSelectionViewController)
}
public protocol TrackSelectionViewController : UIKit.UIViewController {
  var trackSelectionDelegate: (any BanubaUtilities.TrackSelectionViewControllerDelegate)? { get set }
}
public enum Connection : Swift.CustomStringConvertible {
  case none, wifi, cellular
  public var description: Swift.String {
    get
  }
  public static func == (a: BanubaUtilities.Connection, b: BanubaUtilities.Connection) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol AlertViewControllerFactory : AnyObject {
  func getAlertViewController() -> BanubaUtilities.AlertViewController?
  func getPopoverAlertViewController() -> BanubaUtilities.PopoverAlertViewController?
}
extension BanubaUtilities.AlertViewControllerFactory where Self : UIKit.UIViewController {
  public func getPopoverAlertViewController() -> BanubaUtilities.PopoverAlertViewController?
}
public protocol AlertPresentable : BanubaUtilities.AlertViewControllerFactory {
  func presentAlertViewController(alertType: BanubaUtilities.AlertViewController.AlertType, title: Swift.String, message: Swift.String?, animated: Swift.Bool, completion: ((Swift.Bool, BanubaUtilities.AlertViewController.ButtonType?) -> Swift.Void)?)
  func presentSelectionAlert(title: Swift.String, message: Swift.String?, animated: Swift.Bool, completion: ((Swift.Bool, BanubaUtilities.AlertViewController.ButtonType?) -> Swift.Void)?)
  func presentSelectionAlert(withTitle title: Swift.String, message: Swift.String?, agreeButtonTitle: Swift.String?, disagreeButtonTitle: Swift.String?, animated: Swift.Bool, completion: @escaping ((_ success: Swift.Bool, _ buttonType: BanubaUtilities.AlertViewController.ButtonType?) -> Swift.Void))
  func presentPopoverAlert(position: BanubaUtilities.OverlayPopoverActionsPosition, actions: [BanubaUtilities.PopoverAlertViewController.ActionType], animated: Swift.Bool, completion: @escaping ((BanubaUtilities.PopoverAlertViewController.ActionType) -> Swift.Void))
}
extension BanubaUtilities.AlertPresentable where Self : UIKit.UIViewController {
  public func presentAlertViewController(alertType: BanubaUtilities.AlertViewController.AlertType, title: Swift.String, message: Swift.String?, animated: Swift.Bool, completion: ((Swift.Bool, BanubaUtilities.AlertViewController.ButtonType?) -> Swift.Void)?)
  public func presentSelectionAlert(title: Swift.String, message: Swift.String?, animated: Swift.Bool, completion: ((Swift.Bool, BanubaUtilities.AlertViewController.ButtonType?) -> Swift.Void)?)
  public func presentAlert(alertType: BanubaUtilities.AlertViewController.AlertType, title: Swift.String, message: Swift.String?, animated: Swift.Bool = false, completion: ((Swift.Bool, BanubaUtilities.AlertViewController.ButtonType?) -> Swift.Void)?)
  public func presentSelectionAlert(withTitle title: Swift.String, message: Swift.String?, agreeButtonTitle: Swift.String? = nil, disagreeButtonTitle: Swift.String? = nil, animated: Swift.Bool = false, completion: @escaping ((_ success: Swift.Bool, _ buttonType: BanubaUtilities.AlertViewController.ButtonType?) -> Swift.Void))
  public func presentPopoverAlert(position: BanubaUtilities.OverlayPopoverActionsPosition, actions: [BanubaUtilities.PopoverAlertViewController.ActionType], animated: Swift.Bool, completion: @escaping ((BanubaUtilities.PopoverAlertViewController.ActionType) -> Swift.Void))
}
public enum SharedLocalizedStrings {
  public enum Errors {
    public static let noInternetConnection: Swift.String
  }
  public enum Common {
    public static let ok: Swift.String
    public static let yes: Swift.String
    public static let no: Swift.String
  }
  public enum Alert {
    public static let settings: Swift.String
    public static let refuseSettings: Swift.String
  }
  public enum Gallery {
    public static let damagedFile: Swift.String
    public static let exportVideoFailed: Swift.String
  }
  public enum AutoCut {
  }
}
extension Combine.Publisher {
  public func map<T>(to value: T) -> Combine.Publishers.Map<Self, T>
  public func convertToResult() -> Combine.AnyPublisher<Swift.Result<Self.Output, Self.Failure>, Swift.Never>
  public func mapSuccess<T, U, E>(_ transform: @escaping (T) -> Swift.Result<U, any Swift.Error>) -> Combine.Publishers.Map<Self, Swift.Result<U, any Swift.Error>> where E : Swift.Error, Self.Failure == Swift.Never, Self.Output == Swift.Result<T, E>
}
extension Combine.AnyPublisher {
  public static func just(_ output: Output) -> Combine.AnyPublisher<Output, Failure>
}
extension Dispatch.DispatchQueue.SchedulerTimeType.Stride {
  public static var searchFieldDebouncingTime: Dispatch.DispatchQueue.SchedulerTimeType.Stride {
    get
  }
}
extension UIKit.UIButton {
  @_Concurrency.MainActor @preconcurrency public func applyConfiguration(_ configuration: any BanubaUtilities.ImageTextButtonConfigurationProtocol)
  @_Concurrency.MainActor @preconcurrency public func applyConfiguration(_ configuration: any BanubaUtilities.ImageButtonConfigurationProtocol)
  @_Concurrency.MainActor @preconcurrency public func applyConfiguration(_ configuration: BanubaUtilities.BackButtonConfiguration)
  @_Concurrency.MainActor @preconcurrency public func applyConfiguration(_ configuration: BanubaUtilities.RoundedButtonConfiguration)
  @_Concurrency.MainActor @preconcurrency public func applyConfiguration(_ configuration: BanubaUtilities.RoundedButtonConfiguration, with title: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func applyConfiguration(_ configuration: BanubaUtilities.SaveButtonConfiguration)
  @_Concurrency.MainActor @preconcurrency public func applyConfiguration(_ configuration: BanubaUtilities.TextButtonConfiguration, with title: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func applyConfiguration(_ configuration: BanubaUtilities.TextConfiguration?, with title: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func applyConfiguration(_ configuration: (any BanubaUtilities.ImageConfigurationProtocol)?, forState controlState: UIKit.UIControl.State)
}
@objc public class BackgroundConfiguration : ObjectiveC.NSObject {
  public var cornerRadius: CoreFoundation.CGFloat
  public var color: UIKit.UIColor
  public var mode: BanubaUtilities.BackgroundMode
  public init(cornerRadius: CoreFoundation.CGFloat, color: UIKit.UIColor, mode: BanubaUtilities.BackgroundMode = .color)
  @objc deinit
}
public struct BlurCoordinateParams : Swift.Codable {
  public var blurRect: CoreFoundation.CGRect
  public var videoSize: CoreFoundation.CGSize
  public init(blurRect: CoreFoundation.CGRect, videoSize: CoreFoundation.CGSize)
  public init(overlayFrame: CoreFoundation.CGRect, overlayContainerSize: CoreFoundation.CGSize, videoSize: CoreFoundation.CGSize)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum GalleryError : Foundation.CustomNSError, Foundation.LocalizedError {
  case uploadingFailed
  case error(any Swift.Error)
  case uploadingCancelled
  public var isCancelled: Swift.Bool {
    get
  }
  public static var errorDomain: Swift.String
  public var errorDescription: Swift.String? {
    get
  }
}
public protocol TTSegmentedControlDelegate : AnyObject {
  func segmentedViewDidBegin(_ view: BanubaUtilities.TTSegmentedControl)
  func segmentedView(_ view: BanubaUtilities.TTSegmentedControl, didDragAt index: Swift.Int)
  func segmentedView(_ view: BanubaUtilities.TTSegmentedControl, shouldMoveAt index: Swift.Int) -> Swift.Bool
  func segmentedView(_ view: BanubaUtilities.TTSegmentedControl, didEndAt index: Swift.Int)
}
extension BanubaUtilities.TTSegmentedControlDelegate {
  public func segmentedViewDidBegin(_ view: BanubaUtilities.TTSegmentedControl)
  public func segmentedView(_ view: BanubaUtilities.TTSegmentedControl, didDragAt index: Swift.Int)
  public func segmentedView(_ view: BanubaUtilities.TTSegmentedControl, shouldMoveAt index: Swift.Int) -> Swift.Bool
  public func segmentedView(_ view: BanubaUtilities.TTSegmentedControl, didEndAt index: Swift.Int)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class TTSegmentedControl : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency weak final public var delegate: (any BanubaUtilities.TTSegmentedControlDelegate)?
  @_Concurrency.MainActor @preconcurrency final public var selectedIndex: Swift.Int {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var bounceAnimationOptions: BanubaUtilities.TTSegmentedControlBounceOptions?
  @_Concurrency.MainActor @preconcurrency final public var selectionViewShadow: BanubaUtilities.TTSegmentedControlShadow? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var selectionViewInnerShadow: BanubaUtilities.TTSegmentedControlShadow? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var selectionViewBorder: BanubaUtilities.TTSegmentedControlBorder? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var titleDistribution: BanubaUtilities.TTSegmentedControl.TitleDistribution {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var isDragEnabled: Swift.Bool
  @_Concurrency.MainActor @preconcurrency final public var animationOptions: BanubaUtilities.TTSegmentedControlAnimationOption?
  @_Concurrency.MainActor @preconcurrency final public var isSizeAdjustEnabled: Swift.Bool
  @_Concurrency.MainActor @preconcurrency final public var containerViewInnerShadow: BanubaUtilities.TTSegmentedControlShadow? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var containerViewBorder: BanubaUtilities.TTSegmentedControlBorder? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var containerColorType: BanubaUtilities.TTSegmentedControl.ColorType {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var selectionViewColorType: BanubaUtilities.TTSegmentedControl.ColorType {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var selectionViewFillType: BanubaUtilities.TTSegmentedControl.SelectionViewFillType {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var switchSecondSelectionViewColorType: BanubaUtilities.TTSegmentedControl.ColorType? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var padding: CoreFoundation.CGSize {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var cornerRadius: BanubaUtilities.TTSegmentedControl.CornerRadius {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var cornerCurve: QuartzCore.CALayerCornerCurve {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var titles: [BanubaUtilities.TTSegmentedControlTitle] {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var isSwitchBehaviorEnabled: Swift.Bool
  @_Concurrency.MainActor @preconcurrency final public var selectionView: UIKit.UIView {
    get
  }
  @_Concurrency.MainActor @preconcurrency @objc override final public func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension BanubaUtilities.TTSegmentedControl {
  @_Concurrency.MainActor @preconcurrency @objc override final public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency @objc override final public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
}
extension BanubaUtilities.TTSegmentedControl {
  @_Concurrency.MainActor @preconcurrency final public func selectItem(at index: Swift.Int, animated: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency final public func titleForItem(at index: Swift.Int) -> BanubaUtilities.TTSegmentedControlTitle?
}
extension BanubaUtilities.TTSegmentedControl {
  public enum TitleDistribution {
    case fillEqually
    case equalSpacing
    public static func == (a: BanubaUtilities.TTSegmentedControl.TitleDistribution, b: BanubaUtilities.TTSegmentedControl.TitleDistribution) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum SelectionViewFillType {
    case fillSegment
    case fillText
    public static func == (a: BanubaUtilities.TTSegmentedControl.SelectionViewFillType, b: BanubaUtilities.TTSegmentedControl.SelectionViewFillType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum CornerRadius {
    case none
    case maximum
    case constant(value: CoreFoundation.CGFloat)
  }
  public enum ColorType {
    case color(value: UIKit.UIColor)
    case gradient(value: BanubaUtilities.TTSegmentedControlGradient)
    case colorWithGradient(color: UIKit.UIColor, gradient: BanubaUtilities.TTSegmentedControlGradient)
  }
}
extension AVFoundation.AVAssetTrack {
  public var fixedPreferredTransform: CoreFoundation.CGAffineTransform {
    get
  }
}
extension UIKit.UIColor {
  public var colorComponents: (red: CoreFoundation.CGFloat, green: CoreFoundation.CGFloat, blue: CoreFoundation.CGFloat, alpha: CoreFoundation.CGFloat)? {
    get
  }
  convenience public init(red: Swift.Int, green: Swift.Int, blue: Swift.Int, a: CoreFoundation.CGFloat = 1.0)
  convenience public init(rgb: Swift.Int, a: CoreFoundation.CGFloat = 1.0)
}
@_inheritsConvenienceInitializers @objc public class ZipArchive : ObjectiveC.NSObject {
  public static func zip(to destinationUrl: Foundation.URL, folderUrl: Foundation.URL) -> Swift.Bool
  public static func unzip(at sourceUrl: Foundation.URL, destination: Foundation.URL, overwrite: Swift.Bool) throws
  @discardableResult
  public static func unzip(at sourceUrl: Foundation.URL, destination: Foundation.URL, overwrite: Swift.Bool) async throws -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
public protocol ImageDownloaderDelegate : AnyObject {
  func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, willDownloadImageForURL url: Foundation.URL, with request: Foundation.URLRequest?)
  func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didFinishDownloadingImageForURL url: Foundation.URL, with response: Foundation.URLResponse?, error: (any Swift.Error)?)
  func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didDownload data: Foundation.Data, with dataTask: BanubaUtilities.SessionDataTask) -> Foundation.Data?
  func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didDownload data: Foundation.Data, for url: Foundation.URL) -> Foundation.Data?
  func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didDownload image: BanubaUtilities.KFCrossPlatformImage, for url: Foundation.URL, with response: Foundation.URLResponse?)
  func isValidStatusCode(_ code: Swift.Int, for downloader: BanubaUtilities.ImageDownloader) -> Swift.Bool
  func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didReceive response: Foundation.URLResponse) async -> Foundation.URLSession.ResponseDisposition
}
extension BanubaUtilities.ImageDownloaderDelegate {
  public func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, willDownloadImageForURL url: Foundation.URL, with request: Foundation.URLRequest?)
  public func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didFinishDownloadingImageForURL url: Foundation.URL, with response: Foundation.URLResponse?, error: (any Swift.Error)?)
  public func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didDownload image: BanubaUtilities.KFCrossPlatformImage, for url: Foundation.URL, with response: Foundation.URLResponse?)
  public func isValidStatusCode(_ code: Swift.Int, for downloader: BanubaUtilities.ImageDownloader) -> Swift.Bool
  public func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didDownload data: Foundation.Data, with task: BanubaUtilities.SessionDataTask) -> Foundation.Data?
  public func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didDownload data: Foundation.Data, for url: Foundation.URL) -> Foundation.Data?
  public func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didReceive response: Foundation.URLResponse) async -> Foundation.URLSession.ResponseDisposition
}
public protocol Resource : Swift.Sendable {
  var cacheKey: Swift.String { get }
  var downloadURL: Foundation.URL { get }
}
extension BanubaUtilities.Resource {
  public func convertToSource(overrideCacheKey: Swift.String? = nil) -> BanubaUtilities.Source
}
@available(*, deprecated, renamed: "KF.ImageResource", message: "This type conflicts with `GeneratedAssetSymbols.ImageResource` in Swift 5.9. Renamed to avoid issues in the future.")
public typealias ImageResource = BanubaUtilities.KF.ImageResource
extension BanubaUtilities.KF {
  public struct ImageResource : BanubaUtilities.Resource {
    public init(downloadURL: Foundation.URL, cacheKey: Swift.String? = nil)
    public let cacheKey: Swift.String
    public let downloadURL: Foundation.URL
  }
}
extension Foundation.URL : BanubaUtilities.Resource {
  public var cacheKey: Swift.String {
    get
  }
  public var downloadURL: Foundation.URL {
    get
  }
}
@_Concurrency.MainActor extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIImageView {
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: BanubaUtilities.Source?, placeholder: (any BanubaUtilities.Placeholder)? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: BanubaUtilities.Source?, placeholder: (any BanubaUtilities.Placeholder)? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any BanubaUtilities.Resource)?, placeholder: (any BanubaUtilities.Placeholder)? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any BanubaUtilities.Resource)?, placeholder: (any BanubaUtilities.Placeholder)? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  @_Concurrency.MainActor public func setImage(with provider: (any BanubaUtilities.ImageDataProvider)?, placeholder: (any BanubaUtilities.Placeholder)? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  @_Concurrency.MainActor public func setImage(with provider: (any BanubaUtilities.ImageDataProvider)?, placeholder: (any BanubaUtilities.Placeholder)? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @_Concurrency.MainActor public func cancelDownloadTask()
}
@_Concurrency.MainActor extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIImageView {
  @_Concurrency.MainActor public var taskIdentifier: BanubaUtilities.Source.Identifier.Value? {
    get
  }
  @_Concurrency.MainActor public var indicatorType: BanubaUtilities.IndicatorType {
    get
    set
  }
  @_Concurrency.MainActor public var indicator: (any BanubaUtilities.Indicator)? {
    get
  }
  @_Concurrency.MainActor public var placeholder: (any BanubaUtilities.Placeholder)? {
    get
  }
}
extension Foundation.NSNotification.Name {
  public static let KingfisherDidCleanDiskCache: Foundation.Notification.Name
}
public let KingfisherDiskCacheCleanedHashKey: Swift.String
public enum CacheType : Swift.Sendable {
  case none
  case memory
  case disk
  public var cached: Swift.Bool {
    get
  }
  public static func == (a: BanubaUtilities.CacheType, b: BanubaUtilities.CacheType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct CacheStoreResult : Swift.Sendable {
  public let memoryCacheResult: Swift.Result<(), Swift.Never>
  public let diskCacheResult: Swift.Result<(), BanubaUtilities.KingfisherError>
}
extension UIKit.UIImage : BanubaUtilities.CacheCostCalculable {
  public var cacheCost: Swift.Int {
    get
  }
}
extension Foundation.Data : BanubaUtilities.DataTransformable {
  public func toData() throws -> Foundation.Data
  public static func fromData(_ data: Foundation.Data) throws -> Foundation.Data
  public static let empty: Foundation.Data
}
public enum ImageCacheResult : Swift.Sendable {
  case disk(BanubaUtilities.KFCrossPlatformImage)
  case memory(BanubaUtilities.KFCrossPlatformImage)
  case none
  public var image: BanubaUtilities.KFCrossPlatformImage? {
    get
  }
  public var cacheType: BanubaUtilities.CacheType {
    get
  }
}
open class ImageCache : @unchecked Swift.Sendable {
  public static let `default`: BanubaUtilities.ImageCache
  final public let memoryStorage: BanubaUtilities.MemoryStorage.Backend<BanubaUtilities.KFCrossPlatformImage>
  final public let diskStorage: BanubaUtilities.DiskStorage.Backend<Foundation.Data>
  public typealias DiskCachePathClosure = @Sendable (Foundation.URL, Swift.String) -> Foundation.URL
  public init(memoryStorage: BanubaUtilities.MemoryStorage.Backend<BanubaUtilities.KFCrossPlatformImage>, diskStorage: BanubaUtilities.DiskStorage.Backend<Foundation.Data>)
  convenience public init(name: Swift.String)
  convenience public init(name: Swift.String, cacheDirectoryURL: Foundation.URL?, diskCachePathClosure: BanubaUtilities.ImageCache.DiskCachePathClosure? = nil) throws
  @objc deinit
  open func store(_ image: BanubaUtilities.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, options: BanubaUtilities.KingfisherParsedOptionsInfo, toDisk: Swift.Bool = true, completionHandler: (@Sendable (BanubaUtilities.CacheStoreResult) -> Swift.Void)? = nil)
  open func store(_ image: BanubaUtilities.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", cacheSerializer serializer: any BanubaUtilities.CacheSerializer = DefaultCacheSerializer.default, toDisk: Swift.Bool = true, callbackQueue: BanubaUtilities.CallbackQueue = .untouch, completionHandler: (@Sendable (BanubaUtilities.CacheStoreResult) -> Swift.Void)? = nil)
  open func storeToDisk(_ data: Foundation.Data, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", expiration: BanubaUtilities.StorageExpiration? = nil, callbackQueue: BanubaUtilities.CallbackQueue = .untouch, completionHandler: (@Sendable (BanubaUtilities.CacheStoreResult) -> Swift.Void)? = nil)
  open func removeImage(forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", fromMemory: Swift.Bool = true, fromDisk: Swift.Bool = true, callbackQueue: BanubaUtilities.CallbackQueue = .untouch, completionHandler: (@Sendable () -> Swift.Void)? = nil)
  open func retrieveImage(forKey key: Swift.String, options: BanubaUtilities.KingfisherParsedOptionsInfo, callbackQueue: BanubaUtilities.CallbackQueue = .mainCurrentOrAsync, completionHandler: (@Sendable (Swift.Result<BanubaUtilities.ImageCacheResult, BanubaUtilities.KingfisherError>) -> Swift.Void)?)
  open func retrieveImage(forKey key: Swift.String, options: BanubaUtilities.KingfisherOptionsInfo? = nil, callbackQueue: BanubaUtilities.CallbackQueue = .mainCurrentOrAsync, completionHandler: (@Sendable (Swift.Result<BanubaUtilities.ImageCacheResult, BanubaUtilities.KingfisherError>) -> Swift.Void)?)
  open func retrieveImageInMemoryCache(forKey key: Swift.String, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
  open func retrieveImageInMemoryCache(forKey key: Swift.String, options: BanubaUtilities.KingfisherOptionsInfo? = nil) -> BanubaUtilities.KFCrossPlatformImage?
  open func retrieveImageInDiskCache(forKey key: Swift.String, options: BanubaUtilities.KingfisherOptionsInfo? = nil, callbackQueue: BanubaUtilities.CallbackQueue = .untouch, completionHandler: @escaping @Sendable (Swift.Result<BanubaUtilities.KFCrossPlatformImage?, BanubaUtilities.KingfisherError>) -> Swift.Void)
  public func clearCache(completion handler: (@Sendable () -> Swift.Void)? = nil)
  @objc public func clearMemoryCache()
  open func clearDiskCache(completion handler: (@Sendable () -> Swift.Void)? = nil)
  open func cleanExpiredCache(completion handler: (@Sendable () -> Swift.Void)? = nil)
  open func cleanExpiredMemoryCache()
  open func cleanExpiredDiskCache(completion handler: (@Sendable () -> Swift.Void)? = nil)
  @_Concurrency.MainActor @objc public func backgroundCleanExpiredDiskCache()
  open func imageCachedType(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> BanubaUtilities.CacheType
  public func isCached(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> Swift.Bool
  open func hash(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> Swift.String
  open func calculateDiskStorageSize(completion handler: @escaping (@Sendable (Swift.Result<Swift.UInt, BanubaUtilities.KingfisherError>) -> Swift.Void))
  open func cachePath(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> Swift.String
  open func store(_ image: BanubaUtilities.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, options: BanubaUtilities.KingfisherParsedOptionsInfo, toDisk: Swift.Bool = true) async throws
  open func store(_ image: BanubaUtilities.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", cacheSerializer serializer: any BanubaUtilities.CacheSerializer = DefaultCacheSerializer.default, toDisk: Swift.Bool = true) async throws
  open func storeToDisk(_ data: Foundation.Data, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", expiration: BanubaUtilities.StorageExpiration? = nil) async throws
  open func removeImage(forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", fromMemory: Swift.Bool = true, fromDisk: Swift.Bool = true) async throws
  open func retrieveImage(forKey key: Swift.String, options: BanubaUtilities.KingfisherParsedOptionsInfo) async throws -> BanubaUtilities.ImageCacheResult
  open func retrieveImage(forKey key: Swift.String, options: BanubaUtilities.KingfisherOptionsInfo? = nil) async throws -> BanubaUtilities.ImageCacheResult
  open func retrieveImageInDiskCache(forKey key: Swift.String, options: BanubaUtilities.KingfisherOptionsInfo? = nil) async throws -> BanubaUtilities.KFCrossPlatformImage?
  open func clearCache() async
  open func clearDiskCache() async
  open func cleanExpiredCache() async
  open func cleanExpiredDiskCache() async
  open var diskStorageSize: Swift.UInt {
    get async throws
  }
}
extension UIKit.UIApplication : BanubaUtilities.KingfisherCompatible {
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIApplication {
  public static var shared: UIKit.UIApplication? {
    get
  }
}
public typealias PrefetcherProgressBlock = ((_ skippedResources: [any BanubaUtilities.Resource], _ failedResources: [any BanubaUtilities.Resource], _ completedResources: [any BanubaUtilities.Resource]) -> Swift.Void)
public typealias PrefetcherSourceProgressBlock = ((_ skippedSources: [BanubaUtilities.Source], _ failedSources: [BanubaUtilities.Source], _ completedSources: [BanubaUtilities.Source]) -> Swift.Void)
public typealias PrefetcherCompletionHandler = ((_ skippedResources: [any BanubaUtilities.Resource], _ failedResources: [any BanubaUtilities.Resource], _ completedResources: [any BanubaUtilities.Resource]) -> Swift.Void)
public typealias PrefetcherSourceCompletionHandler = ((_ skippedSources: [BanubaUtilities.Source], _ failedSources: [BanubaUtilities.Source], _ completedSources: [BanubaUtilities.Source]) -> Swift.Void)
@_hasMissingDesignatedInitializers public class ImagePrefetcher : Swift.CustomStringConvertible, @unchecked Swift.Sendable {
  public var description: Swift.String {
    get
  }
  public var maxConcurrentDownloads: Swift.Int
  convenience public init(urls: [Foundation.URL], options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.PrefetcherProgressBlock? = nil, completionHandler: BanubaUtilities.PrefetcherCompletionHandler? = nil)
  convenience public init(resources: [any BanubaUtilities.Resource], options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.PrefetcherProgressBlock? = nil, completionHandler: BanubaUtilities.PrefetcherCompletionHandler? = nil)
  convenience public init(sources: [BanubaUtilities.Source], options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.PrefetcherSourceProgressBlock? = nil, completionHandler: BanubaUtilities.PrefetcherSourceCompletionHandler? = nil)
  public func start()
  public func stop()
  @objc deinit
}
public typealias DownloadProgressBlock = ((_ receivedSize: Swift.Int64, _ totalSize: Swift.Int64) -> Swift.Void)
public struct RetrieveImageResult : Swift.Sendable {
  public let image: BanubaUtilities.KFCrossPlatformImage
  public let cacheType: BanubaUtilities.CacheType
  public let source: BanubaUtilities.Source
  public let originalSource: BanubaUtilities.Source
  public let data: @Sendable () -> Foundation.Data?
}
public struct PropagationError : Swift.Sendable {
  public let source: BanubaUtilities.Source
  public let error: BanubaUtilities.KingfisherError
}
public typealias DownloadTaskUpdatedBlock = (@Sendable (_ newTask: BanubaUtilities.DownloadTask?) -> Swift.Void)
public class KingfisherManager : @unchecked Swift.Sendable {
  public static let shared: BanubaUtilities.KingfisherManager
  public var cache: BanubaUtilities.ImageCache {
    get
    set
  }
  public var downloader: BanubaUtilities.ImageDownloader {
    get
    set
  }
  public var defaultOptions: BanubaUtilities.KingfisherOptionsInfo
  public init(downloader: BanubaUtilities.ImageDownloader, cache: BanubaUtilities.ImageCache)
  @discardableResult
  public func retrieveImage(with resource: any BanubaUtilities.Resource, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, downloadTaskUpdated: BanubaUtilities.DownloadTaskUpdatedBlock? = nil, completionHandler: (@Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)?) -> BanubaUtilities.DownloadTask?
  @discardableResult
  public func retrieveImage(with source: BanubaUtilities.Source, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, downloadTaskUpdated: BanubaUtilities.DownloadTaskUpdatedBlock? = nil, completionHandler: (@Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)?) -> BanubaUtilities.DownloadTask?
  @objc deinit
}
extension BanubaUtilities.KingfisherManager {
  public func retrieveImage(with resource: any BanubaUtilities.Resource, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil) async throws -> BanubaUtilities.RetrieveImageResult
  public func retrieveImage(with source: BanubaUtilities.Source, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil) async throws -> BanubaUtilities.RetrieveImageResult
}
public protocol ImageModifier : Swift.Sendable {
  func modify(_ image: BanubaUtilities.KFCrossPlatformImage) -> BanubaUtilities.KFCrossPlatformImage
}
public struct AnyImageModifier : BanubaUtilities.ImageModifier {
  public init(modify: @escaping @Sendable (BanubaUtilities.KFCrossPlatformImage) throws -> BanubaUtilities.KFCrossPlatformImage)
  public func modify(_ image: BanubaUtilities.KFCrossPlatformImage) -> BanubaUtilities.KFCrossPlatformImage
}
public struct RenderingModeImageModifier : BanubaUtilities.ImageModifier {
  public let renderingMode: UIKit.UIImage.RenderingMode
  public init(renderingMode: UIKit.UIImage.RenderingMode = .automatic)
  public func modify(_ image: BanubaUtilities.KFCrossPlatformImage) -> BanubaUtilities.KFCrossPlatformImage
}
public struct FlipsForRightToLeftLayoutDirectionImageModifier : BanubaUtilities.ImageModifier {
  public init()
  public func modify(_ image: BanubaUtilities.KFCrossPlatformImage) -> BanubaUtilities.KFCrossPlatformImage
}
public struct AlignmentRectInsetsImageModifier : BanubaUtilities.ImageModifier {
  public let alignmentInsets: UIKit.UIEdgeInsets
  public init(alignmentInsets: UIKit.UIEdgeInsets)
  public func modify(_ image: BanubaUtilities.KFCrossPlatformImage) -> BanubaUtilities.KFCrossPlatformImage
}
extension Swift.String : BanubaUtilities.KingfisherCompatibleValue {
}
public class Delegate<Input, Output> : @unchecked Swift.Sendable {
  public init()
  public func delegate<T>(on target: T, block: ((T, Input) -> Output)?) where T : AnyObject
  public func delegate<T>(on target: T, block: ((T, Input) async -> Output)?) where T : AnyObject
  public func call(_ input: Input) -> Output?
  public func callAsFunction(_ input: Input) -> Output?
  public func callAsync(_ input: Input) async -> Output?
  public var isSet: Swift.Bool {
    get
  }
  @objc deinit
}
extension BanubaUtilities.Delegate where Input == () {
  public func call() -> Output?
  public func callAsFunction() -> Output?
}
extension BanubaUtilities.Delegate where Input == (), Output : BanubaUtilities.OptionalProtocol {
  public func call() -> Output
  public func callAsFunction() -> Output
}
extension BanubaUtilities.Delegate where Output : BanubaUtilities.OptionalProtocol {
  public func call(_ input: Input) -> Output
  public func callAsFunction(_ input: Input) -> Output
}
public protocol OptionalProtocol {
  static var _createNil: Self { get }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional : BanubaUtilities.OptionalProtocol {
  public static var _createNil: Swift.Optional<Wrapped> {
    get
  }
}
#else
extension Swift.Optional : BanubaUtilities.OptionalProtocol {
  public static var _createNil: Swift.Optional<Wrapped> {
    get
  }
}
#endif
public typealias Transformer = (CoreImage.CIImage) -> CoreImage.CIImage?
public protocol CIImageProcessor : BanubaUtilities.ImageProcessor {
  var filter: BanubaUtilities.Filter { get }
}
extension BanubaUtilities.CIImageProcessor {
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct Filter {
  public init(transform: @escaping BanubaUtilities.Transformer)
  public static let tint: @Sendable (_ color: BanubaUtilities.KFCrossPlatformColor) -> BanubaUtilities.Filter
  public struct ColorElement {
    public let brightness: CoreFoundation.CGFloat
    public let contrast: CoreFoundation.CGFloat
    public let saturation: CoreFoundation.CGFloat
    public let inputEV: CoreFoundation.CGFloat
    public init(brightness: CoreFoundation.CGFloat, contrast: CoreFoundation.CGFloat, saturation: CoreFoundation.CGFloat, inputEV: CoreFoundation.CGFloat)
  }
  public static let colorControl: @Sendable (_ arg: BanubaUtilities.Filter.ColorElement) -> BanubaUtilities.Filter
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIImage {
  public func apply(_ filter: BanubaUtilities.Filter) -> BanubaUtilities.KFCrossPlatformImage
}
public enum KF {
  public static func source(_ source: BanubaUtilities.Source?) -> BanubaUtilities.KF.Builder
  public static func resource(_ resource: (any BanubaUtilities.Resource)?) -> BanubaUtilities.KF.Builder
  public static func url(_ url: Foundation.URL?, cacheKey: Swift.String? = nil) -> BanubaUtilities.KF.Builder
  public static func dataProvider(_ provider: (any BanubaUtilities.ImageDataProvider)?) -> BanubaUtilities.KF.Builder
  public static func data(_ data: Foundation.Data?, cacheKey: Swift.String) -> BanubaUtilities.KF.Builder
}
extension BanubaUtilities.KF {
  @_hasMissingDesignatedInitializers public class Builder : @unchecked Swift.Sendable {
    public var options: BanubaUtilities.KingfisherParsedOptionsInfo {
      get
      set
    }
    final public let onFailureDelegate: BanubaUtilities.Delegate<BanubaUtilities.KingfisherError, Swift.Void>
    final public let onSuccessDelegate: BanubaUtilities.Delegate<BanubaUtilities.RetrieveImageResult, Swift.Void>
    final public let onProgressDelegate: BanubaUtilities.Delegate<(Swift.Int64, Swift.Int64), Swift.Void>
    @objc deinit
  }
}
@_Concurrency.MainActor extension BanubaUtilities.KF.Builder {
  @discardableResult
  @_Concurrency.MainActor public func set(to imageView: BanubaUtilities.KFCrossPlatformImageView) -> BanubaUtilities.DownloadTask?
  @discardableResult
  @_Concurrency.MainActor public func set(to attachment: UIKit.NSTextAttachment, attributedView: @autoclosure @escaping @Sendable () -> BanubaUtilities.KFCrossPlatformView) -> BanubaUtilities.DownloadTask?
  @discardableResult
  @_Concurrency.MainActor public func set(to button: UIKit.UIButton, for state: UIKit.UIControl.State) -> BanubaUtilities.DownloadTask?
  @discardableResult
  @_Concurrency.MainActor public func setBackground(to button: UIKit.UIButton, for state: UIKit.UIControl.State) -> BanubaUtilities.DownloadTask?
  @available(iOS 14.0, *)
  @discardableResult
  @_Concurrency.MainActor public func set(to listItem: CarPlay.CPListItem) -> BanubaUtilities.DownloadTask?
}
extension BanubaUtilities.KF.Builder {
  public func placeholder(_ placeholder: (any BanubaUtilities.Placeholder)?) -> Self
  public func placeholder(_ image: BanubaUtilities.KFCrossPlatformImage?) -> Self
}
extension BanubaUtilities.KF.Builder {
  public func transition(_ transition: BanubaUtilities.ImageTransition) -> Self
  public func fade(duration: Foundation.TimeInterval) -> Self
  public func keepCurrentImageWhileLoading(_ enabled: Swift.Bool = true) -> Self
  public func onlyLoadFirstFrame(_ enabled: Swift.Bool = true) -> Self
  public func progressiveJPEG(_ progressive: BanubaUtilities.ImageProgressive? = .init()) -> Self
}
extension BanubaUtilities.KF.Builder {
  @available(*, deprecated, message: "This is not necessary anymore since `@StateObject` is used. It does nothing now and please just remove it.")
  public func loadImmediately(_ start: Swift.Bool = true) -> Self
}
extension BanubaUtilities.KF {
  public struct RedirectPayload {
    public let task: BanubaUtilities.SessionDataTask
    public let response: Foundation.HTTPURLResponse
    public let newRequest: Foundation.URLRequest
    public let completionHandler: (Foundation.URLRequest?) -> Swift.Void
  }
}
@_Concurrency.MainActor public protocol KFOptionSetter {
  @_Concurrency.MainActor var options: BanubaUtilities.KingfisherParsedOptionsInfo { get nonmutating set }
  @_Concurrency.MainActor var onFailureDelegate: BanubaUtilities.Delegate<BanubaUtilities.KingfisherError, Swift.Void> { get }
  @_Concurrency.MainActor var onSuccessDelegate: BanubaUtilities.Delegate<BanubaUtilities.RetrieveImageResult, Swift.Void> { get }
  @_Concurrency.MainActor var onProgressDelegate: BanubaUtilities.Delegate<(Swift.Int64, Swift.Int64), Swift.Void> { get }
}
extension BanubaUtilities.KF.Builder : BanubaUtilities.KFOptionSetter {
}
extension BanubaUtilities.KFOptionSetter {
  @_Concurrency.MainActor public func onProgress(_ block: BanubaUtilities.DownloadProgressBlock?) -> Self
  @_Concurrency.MainActor public func onSuccess(_ block: ((BanubaUtilities.RetrieveImageResult) -> Swift.Void)?) -> Self
  @_Concurrency.MainActor public func onFailure(_ block: ((BanubaUtilities.KingfisherError) -> Swift.Void)?) -> Self
}
extension BanubaUtilities.KFOptionSetter {
  @_Concurrency.MainActor public func targetCache(_ cache: BanubaUtilities.ImageCache) -> Self
  @_Concurrency.MainActor public func originalCache(_ cache: BanubaUtilities.ImageCache) -> Self
  @_Concurrency.MainActor public func downloader(_ downloader: BanubaUtilities.ImageDownloader) -> Self
  @_Concurrency.MainActor public func downloadPriority(_ priority: Swift.Float) -> Self
  @_Concurrency.MainActor public func forceRefresh(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func fromMemoryCacheOrRefresh(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func cacheMemoryOnly(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func waitForCache(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func onlyFromCache(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func backgroundDecode(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func callbackQueue(_ queue: BanubaUtilities.CallbackQueue) -> Self
  @_Concurrency.MainActor public func scaleFactor(_ factor: CoreFoundation.CGFloat) -> Self
  @_Concurrency.MainActor public func cacheOriginalImage(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func diskStoreWriteOptions(_ writingOptions: Foundation.Data.WritingOptions) -> Self
  @_Concurrency.MainActor public func loadDiskFileSynchronously(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func processingQueue(_ queue: BanubaUtilities.CallbackQueue?) -> Self
  @_Concurrency.MainActor public func alternativeSources(_ sources: [BanubaUtilities.Source]?) -> Self
  @_Concurrency.MainActor public func retry(_ strategy: (any BanubaUtilities.RetryStrategy)?) -> Self
  @_Concurrency.MainActor public func retry(maxCount: Swift.Int, interval: BanubaUtilities.DelayRetryStrategy.Interval = .seconds(3)) -> Self
  @_Concurrency.MainActor public func lowDataModeSource(_ source: BanubaUtilities.Source?) -> Self
  @_Concurrency.MainActor public func forceTransition(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func onFailureImage(_ image: BanubaUtilities.KFCrossPlatformImage?) -> Self
}
extension BanubaUtilities.KFOptionSetter {
  @_Concurrency.MainActor public func requestModifier(_ modifier: any BanubaUtilities.AsyncImageDownloadRequestModifier) -> Self
  @_Concurrency.MainActor public func requestModifier(_ modifyBlock: @escaping @Sendable (inout Foundation.URLRequest) -> Swift.Void) -> Self
}
extension BanubaUtilities.KFOptionSetter {
  @_Concurrency.MainActor public func redirectHandler(_ handler: any BanubaUtilities.ImageDownloadRedirectHandler) -> Self
  @_Concurrency.MainActor public func redirectHandler(_ block: @escaping @Sendable (BanubaUtilities.KF.RedirectPayload) -> Swift.Void) -> Self
}
extension BanubaUtilities.KFOptionSetter {
  @_Concurrency.MainActor public func setProcessor(_ processor: any BanubaUtilities.ImageProcessor) -> Self
  @_Concurrency.MainActor public func setProcessors(_ processors: [any BanubaUtilities.ImageProcessor]) -> Self
  @_Concurrency.MainActor public func appendProcessor(_ processor: any BanubaUtilities.ImageProcessor) -> Self
  @_Concurrency.MainActor public func roundCorner(radius: BanubaUtilities.Radius, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: BanubaUtilities.RectCorner = .all, backgroundColor: BanubaUtilities.KFCrossPlatformColor? = nil) -> Self
  @_Concurrency.MainActor public func blur(radius: CoreFoundation.CGFloat) -> Self
  @_Concurrency.MainActor public func overlay(color: BanubaUtilities.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat = 0.5) -> Self
  @_Concurrency.MainActor public func tint(color: BanubaUtilities.KFCrossPlatformColor) -> Self
  @_Concurrency.MainActor public func blackWhite() -> Self
  @_Concurrency.MainActor public func cropping(size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint = .init(x: 0.5, y: 0.5)) -> Self
  @_Concurrency.MainActor public func downsampling(size: CoreFoundation.CGSize) -> Self
  @_Concurrency.MainActor public func resizing(referenceSize: CoreFoundation.CGSize, mode: BanubaUtilities.ContentMode = .none) -> Self
}
extension BanubaUtilities.KFOptionSetter {
  @_Concurrency.MainActor public func serialize(by cacheSerializer: any BanubaUtilities.CacheSerializer) -> Self
  @_Concurrency.MainActor public func serialize(as format: BanubaUtilities.ImageFormat, jpegCompressionQuality: CoreFoundation.CGFloat? = nil) -> Self
}
extension BanubaUtilities.KFOptionSetter {
  @_Concurrency.MainActor public func imageModifier(_ modifier: (any BanubaUtilities.ImageModifier)?) -> Self
  @_Concurrency.MainActor public func imageModifier(_ block: @escaping @Sendable (inout BanubaUtilities.KFCrossPlatformImage) throws -> Swift.Void) -> Self
}
extension BanubaUtilities.KFOptionSetter {
  @_Concurrency.MainActor public func memoryCacheExpiration(_ expiration: BanubaUtilities.StorageExpiration?) -> Self
  @_Concurrency.MainActor public func memoryCacheAccessExtending(_ extending: BanubaUtilities.ExpirationExtending) -> Self
  @_Concurrency.MainActor public func diskCacheExpiration(_ expiration: BanubaUtilities.StorageExpiration?) -> Self
  @_Concurrency.MainActor public func diskCacheAccessExtending(_ extending: BanubaUtilities.ExpirationExtending) -> Self
}
public struct ImageCreatingOptions {
  public var scale: CoreFoundation.CGFloat
  public var duration: Foundation.TimeInterval
  public var preloadAll: Swift.Bool
  public var onlyFirstFrame: Swift.Bool
  public init(scale: CoreFoundation.CGFloat = 1.0, duration: Foundation.TimeInterval = 0.0, preloadAll: Swift.Bool = false, onlyFirstFrame: Swift.Bool = false)
}
@_hasMissingDesignatedInitializers public class GIFAnimatedImage {
  public static func getFrameDuration(from gifInfo: [Swift.String : Any]?) -> Foundation.TimeInterval
  public static func getFrameDuration(from imageSource: ImageIO.CGImageSource, at index: Swift.Int) -> Foundation.TimeInterval
  @objc deinit
}
public protocol ImageFrameSource {
  var data: Foundation.Data? { get }
  var frameCount: Swift.Int { get }
  func frame(at index: Swift.Int, maxSize: CoreFoundation.CGSize?) -> CoreGraphics.CGImage?
  func duration(at index: Swift.Int) -> Foundation.TimeInterval
}
extension BanubaUtilities.ImageFrameSource {
  public func frame(at index: Swift.Int) -> CoreGraphics.CGImage?
}
public typealias KFCrossPlatformImage = UIKit.UIImage
public typealias KFCrossPlatformColor = UIKit.UIColor
public typealias KFCrossPlatformImageView = UIKit.UIImageView
public typealias KFCrossPlatformView = UIKit.UIView
public typealias KFCrossPlatformButton = UIKit.UIButton
public struct KingfisherWrapper<Base> : @unchecked Swift.Sendable {
  public let base: Base
  public init(_ base: Base)
}
public protocol KingfisherCompatible : AnyObject {
}
public protocol KingfisherCompatibleValue {
}
extension BanubaUtilities.KingfisherCompatible {
  public var kf: BanubaUtilities.KingfisherWrapper<Self> {
    get
    set
  }
}
extension BanubaUtilities.KingfisherCompatibleValue {
  public var kf: BanubaUtilities.KingfisherWrapper<Self> {
    get
    set
  }
}
extension UIKit.UIImage : BanubaUtilities.KingfisherCompatible {
}
extension UIKit.UIImageView : BanubaUtilities.KingfisherCompatible {
}
extension UIKit.UIButton : BanubaUtilities.KingfisherCompatible {
}
extension UIKit.NSTextAttachment : BanubaUtilities.KingfisherCompatible {
}
@available(iOS 14.0, *)
extension CarPlay.CPListItem : BanubaUtilities.KingfisherCompatible {
}
public protocol Placeholder {
  @_Concurrency.MainActor func add(to imageView: BanubaUtilities.KFCrossPlatformImageView)
  @_Concurrency.MainActor func remove(from imageView: BanubaUtilities.KFCrossPlatformImageView)
}
@_Concurrency.MainActor extension UIKit.UIImage : BanubaUtilities.Placeholder {
  @_Concurrency.MainActor public func add(to imageView: BanubaUtilities.KFCrossPlatformImageView)
  @_Concurrency.MainActor public func remove(from imageView: BanubaUtilities.KFCrossPlatformImageView)
  @_Concurrency.MainActor public func add(to base: any BanubaUtilities.KingfisherHasImageComponent)
  @_Concurrency.MainActor public func remove(from base: any BanubaUtilities.KingfisherHasImageComponent)
}
@_Concurrency.MainActor extension BanubaUtilities.Placeholder where Self : UIKit.UIView {
  @_Concurrency.MainActor public func add(to imageView: BanubaUtilities.KFCrossPlatformImageView)
  @_Concurrency.MainActor public func remove(from imageView: BanubaUtilities.KFCrossPlatformImageView)
}
public struct ImageProgressive : Swift.Sendable {
  public enum UpdatingStrategy {
    case `default`
    case keepCurrent
    case replace(BanubaUtilities.KFCrossPlatformImage?)
  }
  @available(*, deprecated, renamed: "init()", message: "Getting a default `ImageProgressive` is deprecated due to its syntax semantic is not clear. Use `ImageProgressive.init` instead.")
  public static let `default`: BanubaUtilities.ImageProgressive
  public var isBlur: Swift.Bool
  public var isFastestScan: Swift.Bool
  public var scanInterval: Foundation.TimeInterval
  public let onImageUpdated: BanubaUtilities.Delegate<BanubaUtilities.KFCrossPlatformImage, BanubaUtilities.ImageProgressive.UpdatingStrategy>
  public init()
  public init(isBlur: Swift.Bool, isFastestScan: Swift.Bool, scanInterval: Foundation.TimeInterval)
}
#if compiler(>=5.3) && $RetroactiveAttribute
extension QuartzCore.CADisplayLink : @unchecked @retroactive Swift.Sendable {
}
#else
extension QuartzCore.CADisplayLink : @unchecked Swift.Sendable {
}
#endif
#if compiler(>=5.3) && $RetroactiveAttribute
extension AVFoundation.AVAssetImageGenerator : @unchecked @retroactive Swift.Sendable {
}
#else
extension AVFoundation.AVAssetImageGenerator : @unchecked Swift.Sendable {
}
#endif
public struct AVAssetImageDataProvider : BanubaUtilities.ImageDataProvider {
  public enum AVAssetImageDataProviderError : Swift.Error {
    case userCancelled
    case invalidImage(_: CoreGraphics.CGImage?)
  }
  public let assetImageGenerator: AVFoundation.AVAssetImageGenerator
  public let time: CoreMedia.CMTime
  public var cacheKey: Swift.String {
    get
  }
  public init(assetImageGenerator: AVFoundation.AVAssetImageGenerator, time: CoreMedia.CMTime)
  public init(assetURL: Foundation.URL, time: CoreMedia.CMTime)
  public init(assetURL: Foundation.URL, seconds: Foundation.TimeInterval)
  public func data(handler: @escaping @Sendable (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
}
public enum ImageProcessItem : Swift.Sendable {
  case image(BanubaUtilities.KFCrossPlatformImage)
  case data(Foundation.Data)
}
public protocol ImageProcessor : Swift.Sendable {
  var identifier: Swift.String { get }
  func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
extension BanubaUtilities.ImageProcessor {
  public func append(another: any BanubaUtilities.ImageProcessor) -> any BanubaUtilities.ImageProcessor
}
public struct DefaultImageProcessor : BanubaUtilities.ImageProcessor {
  public static let `default`: BanubaUtilities.DefaultImageProcessor
  public let identifier: Swift.String
  public init()
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct RectCorner : Swift.OptionSet, Swift.Sendable {
  public let rawValue: Swift.Int
  public static let topLeft: BanubaUtilities.RectCorner
  public static let topRight: BanubaUtilities.RectCorner
  public static let bottomLeft: BanubaUtilities.RectCorner
  public static let bottomRight: BanubaUtilities.RectCorner
  public static let all: BanubaUtilities.RectCorner
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = BanubaUtilities.RectCorner
  public typealias Element = BanubaUtilities.RectCorner
  public typealias RawValue = Swift.Int
}
public struct BlendImageProcessor : BanubaUtilities.ImageProcessor {
  public let identifier: Swift.String
  public let blendMode: CoreGraphics.CGBlendMode
  public let alpha: CoreFoundation.CGFloat
  public let backgroundColor: BanubaUtilities.KFCrossPlatformColor?
  public init(blendMode: CoreGraphics.CGBlendMode, alpha: CoreFoundation.CGFloat = 1.0, backgroundColor: BanubaUtilities.KFCrossPlatformColor? = nil)
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public enum Radius : Swift.Sendable {
  case widthFraction(CoreFoundation.CGFloat)
  case heightFraction(CoreFoundation.CGFloat)
  case point(CoreFoundation.CGFloat)
  public func compute(with size: CoreFoundation.CGSize) -> CoreFoundation.CGFloat
}
public struct RoundCornerImageProcessor : BanubaUtilities.ImageProcessor {
  public let identifier: Swift.String
  public let radius: BanubaUtilities.Radius
  public let roundingCorners: BanubaUtilities.RectCorner
  public let targetSize: CoreFoundation.CGSize?
  public let backgroundColor: BanubaUtilities.KFCrossPlatformColor?
  public init(cornerRadius: CoreFoundation.CGFloat, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: BanubaUtilities.RectCorner = .all, backgroundColor: BanubaUtilities.KFCrossPlatformColor? = nil)
  public init(radius: BanubaUtilities.Radius, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: BanubaUtilities.RectCorner = .all, backgroundColor: BanubaUtilities.KFCrossPlatformColor? = nil)
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct Border : Swift.Sendable {
  public var color: BanubaUtilities.KFCrossPlatformColor
  public var lineWidth: CoreFoundation.CGFloat
  public var radius: BanubaUtilities.Radius
  public var roundingCorners: BanubaUtilities.RectCorner
  public init(color: BanubaUtilities.KFCrossPlatformColor = .black, lineWidth: CoreFoundation.CGFloat = 4, radius: BanubaUtilities.Radius = .point(0), roundingCorners: BanubaUtilities.RectCorner = .all)
}
public struct BorderImageProcessor : BanubaUtilities.ImageProcessor {
  public var identifier: Swift.String {
    get
  }
  public let border: BanubaUtilities.Border
  public init(border: BanubaUtilities.Border)
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public enum ContentMode : Swift.Sendable {
  case none
  case aspectFit
  case aspectFill
  public static func == (a: BanubaUtilities.ContentMode, b: BanubaUtilities.ContentMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ResizingImageProcessor : BanubaUtilities.ImageProcessor {
  public let identifier: Swift.String
  public let referenceSize: CoreFoundation.CGSize
  public let targetContentMode: BanubaUtilities.ContentMode
  public init(referenceSize: CoreFoundation.CGSize, mode: BanubaUtilities.ContentMode = .none)
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct BlurImageProcessor : BanubaUtilities.ImageProcessor {
  public let identifier: Swift.String
  public let blurRadius: CoreFoundation.CGFloat
  public init(blurRadius: CoreFoundation.CGFloat)
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct OverlayImageProcessor : BanubaUtilities.ImageProcessor {
  public let identifier: Swift.String
  public let overlay: BanubaUtilities.KFCrossPlatformColor
  public let fraction: CoreFoundation.CGFloat
  public init(overlay: BanubaUtilities.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat = 0.5)
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct TintImageProcessor : BanubaUtilities.ImageProcessor {
  public let identifier: Swift.String
  public let tint: BanubaUtilities.KFCrossPlatformColor
  public init(tint: BanubaUtilities.KFCrossPlatformColor)
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct ColorControlsProcessor : BanubaUtilities.ImageProcessor {
  public let identifier: Swift.String
  public let brightness: CoreFoundation.CGFloat
  public let contrast: CoreFoundation.CGFloat
  public let saturation: CoreFoundation.CGFloat
  public let inputEV: CoreFoundation.CGFloat
  public init(brightness: CoreFoundation.CGFloat, contrast: CoreFoundation.CGFloat, saturation: CoreFoundation.CGFloat, inputEV: CoreFoundation.CGFloat)
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct BlackWhiteProcessor : BanubaUtilities.ImageProcessor {
  public let identifier: Swift.String
  public init()
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct CroppingImageProcessor : BanubaUtilities.ImageProcessor {
  public let identifier: Swift.String
  public let size: CoreFoundation.CGSize
  public let anchor: CoreFoundation.CGPoint
  public init(size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint = CGPoint(x: 0.5, y: 0.5))
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct DownsamplingImageProcessor : BanubaUtilities.ImageProcessor {
  public let size: CoreFoundation.CGSize
  public let identifier: Swift.String
  public init(size: CoreFoundation.CGSize)
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
infix operator |> : AdditionPrecedence
public func |> (left: any BanubaUtilities.ImageProcessor, right: any BanubaUtilities.ImageProcessor) -> any BanubaUtilities.ImageProcessor
@_Concurrency.MainActor extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIButton {
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: BanubaUtilities.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any BanubaUtilities.Resource)?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: BanubaUtilities.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, parsedOptions: BanubaUtilities.KingfisherParsedOptionsInfo, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @_Concurrency.MainActor public func cancelImageDownloadTask()
  @discardableResult
  @_Concurrency.MainActor public func setBackgroundImage(with source: BanubaUtilities.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  @_Concurrency.MainActor public func setBackgroundImage(with resource: (any BanubaUtilities.Resource)?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: (@Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @_Concurrency.MainActor public func cancelBackgroundImageDownloadTask()
}
@_Concurrency.MainActor extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIButton {
  @_Concurrency.MainActor public func taskIdentifier(for state: UIKit.UIControl.State) -> BanubaUtilities.Source.Identifier.Value?
}
@_Concurrency.MainActor extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIButton {
  @_Concurrency.MainActor public func backgroundTaskIdentifier(for state: UIKit.UIControl.State) -> BanubaUtilities.Source.Identifier.Value?
}
public protocol KingfisherImageSettable : BanubaUtilities.KingfisherCompatible {
  @_Concurrency.MainActor func setImage(_ image: BanubaUtilities.KFCrossPlatformImage?, options: BanubaUtilities.KingfisherParsedOptionsInfo)
  @_Concurrency.MainActor func getImage() -> BanubaUtilities.KFCrossPlatformImage?
}
public protocol KingfisherHasImageComponent : BanubaUtilities.KingfisherImageSettable {
  @_Concurrency.MainActor var image: BanubaUtilities.KFCrossPlatformImage? { get set }
}
extension BanubaUtilities.KingfisherHasImageComponent {
  @_Concurrency.MainActor public func setImage(_ image: BanubaUtilities.KFCrossPlatformImage?, options: BanubaUtilities.KingfisherParsedOptionsInfo)
  @_Concurrency.MainActor public func getImage() -> BanubaUtilities.KFCrossPlatformImage?
}
@available(iOS 13.0, tvOS 13.0, *)
extension UIKit.UIAction : BanubaUtilities.KingfisherHasImageComponent {
}
@available(iOS 13.0, tvOS 13.0, *)
extension UIKit.UICommand : BanubaUtilities.KingfisherHasImageComponent {
}
extension UIKit.UIBarItem : BanubaUtilities.KingfisherHasImageComponent {
}
@_Concurrency.MainActor extension BanubaUtilities.KingfisherWrapper where Base : BanubaUtilities.KingfisherImageSettable {
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: BanubaUtilities.Source?, placeholder: BanubaUtilities.KFCrossPlatformImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: BanubaUtilities.Source?, placeholder: BanubaUtilities.KFCrossPlatformImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any BanubaUtilities.Resource)?, placeholder: BanubaUtilities.KFCrossPlatformImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any BanubaUtilities.Resource)?, placeholder: BanubaUtilities.KFCrossPlatformImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  @_Concurrency.MainActor public func setImage(with provider: (any BanubaUtilities.ImageDataProvider)?, placeholder: BanubaUtilities.KFCrossPlatformImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  @_Concurrency.MainActor public func setImage(with provider: (any BanubaUtilities.ImageDataProvider)?, placeholder: BanubaUtilities.KFCrossPlatformImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
}
@_Concurrency.MainActor extension BanubaUtilities.KingfisherWrapper where Base : BanubaUtilities.KingfisherImageSettable {
  @_Concurrency.MainActor public var taskIdentifier: BanubaUtilities.Source.Identifier.Value? {
    get
  }
  @_Concurrency.MainActor public func cancelDownloadTask()
}
public typealias IndicatorView = UIKit.UIView
public enum IndicatorType {
  case none
  case activity
  case image(imageData: Foundation.Data)
  case custom(indicator: any BanubaUtilities.Indicator)
}
@_Concurrency.MainActor public protocol Indicator : Swift.Sendable {
  @_Concurrency.MainActor func startAnimatingView()
  @_Concurrency.MainActor func stopAnimatingView()
  @_Concurrency.MainActor var centerOffset: CoreFoundation.CGPoint { get }
  @_Concurrency.MainActor var view: BanubaUtilities.IndicatorView { get }
  @_Concurrency.MainActor func sizeStrategy(in imageView: BanubaUtilities.KFCrossPlatformImageView) -> BanubaUtilities.IndicatorSizeStrategy
}
public enum IndicatorSizeStrategy {
  case intrinsicSize
  case full
  case size(CoreFoundation.CGSize)
}
extension BanubaUtilities.Indicator {
  @_Concurrency.MainActor public var centerOffset: CoreFoundation.CGPoint {
    get
  }
  @_Concurrency.MainActor public func sizeStrategy(in imageView: BanubaUtilities.KFCrossPlatformImageView) -> BanubaUtilities.IndicatorSizeStrategy
}
public protocol AsyncImageDownloadRequestModifier : Swift.Sendable {
  func modified(for request: Foundation.URLRequest) async -> Foundation.URLRequest?
  var onDownloadTaskStarted: (@Sendable (BanubaUtilities.DownloadTask?) -> Swift.Void)? { get }
}
public protocol ImageDownloadRequestModifier : BanubaUtilities.AsyncImageDownloadRequestModifier {
  func modified(for request: Foundation.URLRequest) -> Foundation.URLRequest?
}
extension BanubaUtilities.ImageDownloadRequestModifier {
  public var onDownloadTaskStarted: (@Sendable (BanubaUtilities.DownloadTask?) -> Swift.Void)? {
    get
  }
}
public struct AnyModifier : BanubaUtilities.ImageDownloadRequestModifier {
  public func modified(for request: Foundation.URLRequest) -> Foundation.URLRequest?
  public init(modify: @escaping @Sendable (Foundation.URLRequest) -> Foundation.URLRequest?)
}
public enum Source : Swift.Sendable {
  public enum Identifier {
    public typealias Value = Swift.UInt
  }
  case network(any BanubaUtilities.Resource)
  case provider(any BanubaUtilities.ImageDataProvider)
  public var cacheKey: Swift.String {
    get
  }
  public var url: Foundation.URL? {
    get
  }
}
extension BanubaUtilities.Source : Swift.Hashable {
  public static func == (lhs: BanubaUtilities.Source, rhs: BanubaUtilities.Source) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIImage {
  public var imageFrameCount: Swift.Int? {
    get
    set
  }
  public var imageSource: ImageIO.CGImageSource? {
    get
  }
  public var frameSource: (any BanubaUtilities.ImageFrameSource)? {
    get
  }
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIImage {
  public var normalized: BanubaUtilities.KFCrossPlatformImage {
    get
  }
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIImage {
  public func pngRepresentation() -> Foundation.Data?
  public func jpegRepresentation(compressionQuality: CoreFoundation.CGFloat) -> Foundation.Data?
  public func gifRepresentation() -> Foundation.Data?
  public func data(format: BanubaUtilities.ImageFormat, compressionQuality: CoreFoundation.CGFloat = 1.0) -> Foundation.Data?
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIImage {
  public static func animatedImage(data: Foundation.Data, options: BanubaUtilities.ImageCreatingOptions) -> BanubaUtilities.KFCrossPlatformImage?
  public static func animatedImage(source: any BanubaUtilities.ImageFrameSource, options: BanubaUtilities.ImageCreatingOptions, baseImage: BanubaUtilities.KFCrossPlatformImage? = nil) -> BanubaUtilities.KFCrossPlatformImage?
  public static func image(data: Foundation.Data, options: BanubaUtilities.ImageCreatingOptions) -> BanubaUtilities.KFCrossPlatformImage?
  public static func downsampledImage(data: Foundation.Data, to pointSize: CoreFoundation.CGSize, scale: CoreFoundation.CGFloat) -> BanubaUtilities.KFCrossPlatformImage?
}
public protocol ImageDataProvider : Swift.Sendable {
  var cacheKey: Swift.String { get }
  func data(handler: @escaping @Sendable (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  var contentURL: Foundation.URL? { get }
}
extension BanubaUtilities.ImageDataProvider {
  public var contentURL: Foundation.URL? {
    get
  }
  public func convertToSource() -> BanubaUtilities.Source
}
public struct LocalFileImageDataProvider : BanubaUtilities.ImageDataProvider {
  public let fileURL: Foundation.URL
  public init(fileURL: Foundation.URL, cacheKey: Swift.String? = nil, loadingQueue: BanubaUtilities.ExecutionQueue = .dispatch(DispatchQueue.global(qos: .userInitiated)))
  public var cacheKey: Swift.String
  public func data(handler: @escaping @Sendable (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  public var data: Foundation.Data {
    get async throws
  }
  public var contentURL: Foundation.URL? {
    get
  }
}
public struct Base64ImageDataProvider : BanubaUtilities.ImageDataProvider {
  public let base64String: Swift.String
  public init(base64String: Swift.String, cacheKey: Swift.String)
  public var cacheKey: Swift.String
  public func data(handler: (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
}
public struct RawImageDataProvider : BanubaUtilities.ImageDataProvider {
  public let data: Foundation.Data
  public init(data: Foundation.Data, cacheKey: Swift.String)
  public var cacheKey: Swift.String
  public func data(handler: @escaping (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
}
extension CoreFoundation.CGSize : BanubaUtilities.KingfisherCompatibleValue {
}
extension BanubaUtilities.KingfisherWrapper where Base == CoreFoundation.CGSize {
  public func resize(to size: CoreFoundation.CGSize, for contentMode: BanubaUtilities.ContentMode) -> CoreFoundation.CGSize
  public func constrained(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func filling(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func constrainedRect(for size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint) -> CoreFoundation.CGRect
}
extension Swift.Comparable {
  public func clamped(to limits: Swift.ClosedRange<Self>) -> Self
}
public typealias KingfisherOptionsInfo = [BanubaUtilities.KingfisherOptionsInfoItem]
public enum KingfisherOptionsInfoItem : Swift.Sendable {
  case targetCache(BanubaUtilities.ImageCache)
  case originalCache(BanubaUtilities.ImageCache)
  case downloader(BanubaUtilities.ImageDownloader)
  case transition(BanubaUtilities.ImageTransition)
  case downloadPriority(Swift.Float)
  case forceRefresh
  case fromMemoryCacheOrRefresh
  case forceTransition
  case cacheMemoryOnly
  case waitForCache
  case onlyFromCache
  case backgroundDecode
  case callbackQueue(BanubaUtilities.CallbackQueue)
  case scaleFactor(CoreFoundation.CGFloat)
  case preloadAllAnimationData
  case requestModifier(any BanubaUtilities.AsyncImageDownloadRequestModifier)
  case redirectHandler(any BanubaUtilities.ImageDownloadRedirectHandler)
  case processor(any BanubaUtilities.ImageProcessor)
  case cacheSerializer(any BanubaUtilities.CacheSerializer)
  case imageModifier(any BanubaUtilities.ImageModifier)
  case keepCurrentImageWhileLoading
  case onlyLoadFirstFrame
  case cacheOriginalImage
  case onFailureImage(BanubaUtilities.KFCrossPlatformImage?)
  case alsoPrefetchToMemory
  case loadDiskFileSynchronously
  case diskStoreWriteOptions(Foundation.Data.WritingOptions)
  case memoryCacheExpiration(BanubaUtilities.StorageExpiration)
  case memoryCacheAccessExtendingExpiration(BanubaUtilities.ExpirationExtending)
  case diskCacheExpiration(BanubaUtilities.StorageExpiration)
  case diskCacheAccessExtendingExpiration(BanubaUtilities.ExpirationExtending)
  case processingQueue(BanubaUtilities.CallbackQueue)
  case progressiveJPEG(BanubaUtilities.ImageProgressive)
  case alternativeSources([BanubaUtilities.Source])
  case retryStrategy(any BanubaUtilities.RetryStrategy)
  case lowDataMode(BanubaUtilities.Source?)
}
public struct KingfisherParsedOptionsInfo : Swift.Sendable {
  public var targetCache: BanubaUtilities.ImageCache?
  public var originalCache: BanubaUtilities.ImageCache?
  public var downloader: BanubaUtilities.ImageDownloader?
  public var transition: BanubaUtilities.ImageTransition
  public var downloadPriority: Swift.Float
  public var forceRefresh: Swift.Bool
  public var fromMemoryCacheOrRefresh: Swift.Bool
  public var forceTransition: Swift.Bool
  public var cacheMemoryOnly: Swift.Bool
  public var waitForCache: Swift.Bool
  public var onlyFromCache: Swift.Bool
  public var backgroundDecode: Swift.Bool
  public var preloadAllAnimationData: Swift.Bool
  public var callbackQueue: BanubaUtilities.CallbackQueue
  public var scaleFactor: CoreFoundation.CGFloat
  public var requestModifier: (any BanubaUtilities.AsyncImageDownloadRequestModifier)?
  public var redirectHandler: (any BanubaUtilities.ImageDownloadRedirectHandler)?
  public var processor: any BanubaUtilities.ImageProcessor
  public var imageModifier: (any BanubaUtilities.ImageModifier)?
  public var cacheSerializer: any BanubaUtilities.CacheSerializer
  public var keepCurrentImageWhileLoading: Swift.Bool
  public var onlyLoadFirstFrame: Swift.Bool
  public var cacheOriginalImage: Swift.Bool
  public var onFailureImage: BanubaUtilities.KFCrossPlatformImage??
  public var alsoPrefetchToMemory: Swift.Bool
  public var loadDiskFileSynchronously: Swift.Bool
  public var diskStoreWriteOptions: Foundation.Data.WritingOptions
  public var memoryCacheExpiration: BanubaUtilities.StorageExpiration?
  public var memoryCacheAccessExtendingExpiration: BanubaUtilities.ExpirationExtending
  public var diskCacheExpiration: BanubaUtilities.StorageExpiration?
  public var diskCacheAccessExtendingExpiration: BanubaUtilities.ExpirationExtending
  public var processingQueue: BanubaUtilities.CallbackQueue?
  public var progressiveJPEG: BanubaUtilities.ImageProgressive?
  public var alternativeSources: [BanubaUtilities.Source]?
  public var retryStrategy: (any BanubaUtilities.RetryStrategy)?
  public var lowDataModeSource: BanubaUtilities.Source?
  public init(_ info: BanubaUtilities.KingfisherOptionsInfo?)
}
public enum StorageExpiration : Swift.Sendable {
  case never
  case seconds(Foundation.TimeInterval)
  case days(Swift.Int)
  case date(Foundation.Date)
  case expired
}
public enum ExpirationExtending : Swift.Sendable {
  case none
  case cacheTime
  case expirationTime(_: BanubaUtilities.StorageExpiration)
}
public protocol CacheCostCalculable {
  var cacheCost: Swift.Int { get }
}
public protocol DataTransformable {
  func toData() throws -> Foundation.Data
  static func fromData(_ data: Foundation.Data) throws -> Self
  static var empty: Self { get }
}
public enum DiskStorage {
  @_hasMissingDesignatedInitializers public class Backend<T> : @unchecked Swift.Sendable where T : BanubaUtilities.DataTransformable {
    public var config: BanubaUtilities.DiskStorage.Config {
      get
      set
    }
    final public let directoryURL: Foundation.URL
    convenience public init(config: BanubaUtilities.DiskStorage.Config) throws
    public func store(value: T, forKey key: Swift.String, expiration: BanubaUtilities.StorageExpiration? = nil, writeOptions: Foundation.Data.WritingOptions = []) throws
    public func value(forKey key: Swift.String, extendingExpiration: BanubaUtilities.ExpirationExtending = .cacheTime) throws -> T?
    public func isCached(forKey key: Swift.String) -> Swift.Bool
    public func isCached(forKey key: Swift.String, referenceDate: Foundation.Date) -> Swift.Bool
    public func remove(forKey key: Swift.String) throws
    public func removeAll() throws
    public func cacheFileURL(forKey key: Swift.String) -> Foundation.URL
    public func removeExpiredValues() throws -> [Foundation.URL]
    public func removeSizeExceededValues() throws -> [Foundation.URL]
    public func totalSize() throws -> Swift.UInt
    @objc deinit
  }
}
extension BanubaUtilities.DiskStorage {
  public struct Config : @unchecked Swift.Sendable {
    public var sizeLimit: Swift.UInt
    public var expiration: BanubaUtilities.StorageExpiration
    public var pathExtension: Swift.String?
    public var usesHashedFileName: Swift.Bool
    public var autoExtAfterHashedFileName: Swift.Bool
    public var cachePathBlock: (@Sendable (_ directory: Foundation.URL, _ cacheName: Swift.String) -> Foundation.URL)!
    public let name: Swift.String
    public init(name: Swift.String, sizeLimit: Swift.UInt, fileManager: Foundation.FileManager = .default, directory: Foundation.URL? = nil)
  }
}
public enum KingfisherError : Swift.Error {
  public enum RequestErrorReason : Swift.Sendable {
    case emptyRequest
    case invalidURL(request: Foundation.URLRequest)
    case taskCancelled(task: BanubaUtilities.SessionDataTask, token: BanubaUtilities.SessionDataTask.CancelToken)
  }
  public enum ResponseErrorReason : Swift.Sendable {
    case invalidURLResponse(response: Foundation.URLResponse)
    case invalidHTTPStatusCode(response: Foundation.HTTPURLResponse)
    case URLSessionError(error: any Swift.Error)
    case dataModifyingFailed(task: BanubaUtilities.SessionDataTask)
    case noURLResponse(task: BanubaUtilities.SessionDataTask)
    case cancelledByDelegate(response: Foundation.URLResponse)
  }
  public enum CacheErrorReason : @unchecked Swift.Sendable {
    case fileEnumeratorCreationFailed(url: Foundation.URL)
    case invalidFileEnumeratorContent(url: Foundation.URL)
    case invalidURLResource(error: any Swift.Error, key: Swift.String, url: Foundation.URL)
    case cannotLoadDataFromDisk(url: Foundation.URL, error: any Swift.Error)
    case cannotCreateDirectory(path: Swift.String, error: any Swift.Error)
    case imageNotExisting(key: Swift.String)
    case cannotConvertToData(object: Any, error: any Swift.Error)
    case cannotSerializeImage(image: BanubaUtilities.KFCrossPlatformImage?, original: Foundation.Data?, serializer: any BanubaUtilities.CacheSerializer)
    case cannotCreateCacheFile(fileURL: Foundation.URL, key: Swift.String, data: Foundation.Data, error: any Swift.Error)
    case cannotSetCacheFileAttribute(filePath: Swift.String, attributes: [Foundation.FileAttributeKey : Any], error: any Swift.Error)
    case diskStorageIsNotReady(cacheURL: Foundation.URL)
  }
  public enum ProcessorErrorReason : Swift.Sendable {
    case processingFailed(processor: any BanubaUtilities.ImageProcessor, item: BanubaUtilities.ImageProcessItem)
  }
  public enum ImageSettingErrorReason : Swift.Sendable {
    case emptySource
    case notCurrentSourceTask(result: BanubaUtilities.RetrieveImageResult?, error: (any Swift.Error)?, source: BanubaUtilities.Source)
    case dataProviderError(provider: any BanubaUtilities.ImageDataProvider, error: any Swift.Error)
    case alternativeSourcesExhausted([BanubaUtilities.PropagationError])
  }
  case requestError(reason: BanubaUtilities.KingfisherError.RequestErrorReason)
  case responseError(reason: BanubaUtilities.KingfisherError.ResponseErrorReason)
  case cacheError(reason: BanubaUtilities.KingfisherError.CacheErrorReason)
  case processorError(reason: BanubaUtilities.KingfisherError.ProcessorErrorReason)
  case imageSettingError(reason: BanubaUtilities.KingfisherError.ImageSettingErrorReason)
  public var isTaskCancelled: Swift.Bool {
    get
  }
  public func isInvalidResponseStatusCode(_ code: Swift.Int) -> Swift.Bool
  public var isInvalidResponseStatusCode: Swift.Bool {
    get
  }
  public var isNotCurrentTask: Swift.Bool {
    get
  }
}
extension BanubaUtilities.KingfisherError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension BanubaUtilities.KingfisherError : Foundation.CustomNSError {
  public static let domain: Swift.String
  public var errorCode: Swift.Int {
    get
  }
}
public typealias ExecutionQueue = BanubaUtilities.CallbackQueue
public enum CallbackQueue : Swift.Sendable {
  case mainAsync
  case mainCurrentOrAsync
  case untouch
  case dispatch(Dispatch.DispatchQueue)
  public func execute(_ block: @escaping @Sendable () -> Swift.Void)
}
@_inheritsConvenienceInitializers @objc(KFSessionDelegate) open class SessionDelegate : ObjectiveC.NSObject, @unchecked Swift.Sendable {
  @objc override dynamic public init()
  @objc deinit
}
extension BanubaUtilities.SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse) async -> Foundation.URLSession.ResponseDisposition
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest) async -> Foundation.URLRequest?
}
public enum ImageTransition : Swift.Sendable {
  case none
  case fade(Foundation.TimeInterval)
  case flipFromLeft(Foundation.TimeInterval)
  case flipFromRight(Foundation.TimeInterval)
  case flipFromTop(Foundation.TimeInterval)
  case flipFromBottom(Foundation.TimeInterval)
  case custom(duration: Foundation.TimeInterval, options: UIKit.UIView.AnimationOptions, animations: (@Sendable (UIKit.UIImageView, UIKit.UIImage) -> Swift.Void)?, completion: (@Sendable (Swift.Bool) -> Swift.Void)?)
}
public enum ImageFormat : Swift.Sendable {
  case unknown
  case PNG
  case JPEG
  case GIF
  public enum JPEGMarker {
    case SOF0
    case SOF2
    case DHT
    case DQT
    case DRI
    case SOS
    case RSTn(Swift.UInt8)
    case APPn
    case COM
    case EOI
  }
  public static func == (a: BanubaUtilities.ImageFormat, b: BanubaUtilities.ImageFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Data : BanubaUtilities.KingfisherCompatibleValue {
}
extension BanubaUtilities.KingfisherWrapper where Base == Foundation.Data {
  public var imageFormat: BanubaUtilities.ImageFormat {
    get
  }
  public func contains(jpeg marker: BanubaUtilities.ImageFormat.JPEGMarker) -> Swift.Bool
}
public protocol CacheSerializer : Swift.Sendable {
  func data(with image: BanubaUtilities.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  func image(with data: Foundation.Data, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
  var originalDataUsed: Swift.Bool { get }
}
extension BanubaUtilities.CacheSerializer {
  public var originalDataUsed: Swift.Bool {
    get
  }
}
public struct DefaultCacheSerializer : BanubaUtilities.CacheSerializer {
  public static let `default`: BanubaUtilities.DefaultCacheSerializer
  public var compressionQuality: CoreFoundation.CGFloat
  public var preferCacheOriginalData: Swift.Bool
  public var originalDataUsed: Swift.Bool {
    get
  }
  public init()
  public func data(with image: BanubaUtilities.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  public func image(with data: Foundation.Data, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
@_Concurrency.MainActor extension BanubaUtilities.KingfisherWrapper where Base : UIKit.NSTextAttachment {
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: BanubaUtilities.Source?, attributedView: @autoclosure @escaping @Sendable () -> BanubaUtilities.KFCrossPlatformView, placeholder: BanubaUtilities.KFCrossPlatformImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any BanubaUtilities.Resource)?, attributedView: @autoclosure @escaping @Sendable () -> BanubaUtilities.KFCrossPlatformView, placeholder: BanubaUtilities.KFCrossPlatformImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @_Concurrency.MainActor public func cancelDownloadTask()
}
@_Concurrency.MainActor extension BanubaUtilities.KingfisherWrapper where Base : UIKit.NSTextAttachment {
  @_Concurrency.MainActor public var taskIdentifier: BanubaUtilities.Source.Identifier.Value? {
    get
  }
}
public protocol AnimatedImageViewDelegate : AnyObject {
  func animatedImageView(_ imageView: BanubaUtilities.AnimatedImageView, didPlayAnimationLoops count: Swift.UInt)
  func animatedImageViewDidFinishAnimating(_ imageView: BanubaUtilities.AnimatedImageView)
}
extension BanubaUtilities.AnimatedImageViewDelegate {
  public func animatedImageView(_ imageView: BanubaUtilities.AnimatedImageView, didPlayAnimationLoops count: Swift.UInt)
  public func animatedImageViewDidFinishAnimating(_ imageView: BanubaUtilities.AnimatedImageView)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class AnimatedImageView : BanubaUtilities.KFCrossPlatformImageView {
  public enum RepeatCount : Swift.Equatable {
    case once
    case finite(count: Swift.UInt)
    case infinite
    public static func == (lhs: BanubaUtilities.AnimatedImageView.RepeatCount, rhs: BanubaUtilities.AnimatedImageView.RepeatCount) -> Swift.Bool
  }
  @_Concurrency.MainActor @preconcurrency public var autoPlayAnimatedImage: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var framePreloadCount: Swift.Int
  @_Concurrency.MainActor @preconcurrency public var needsPrescaling: Swift.Bool
  @available(*, deprecated, message: "    This property does not perform as declared and may lead to performance degradation.\n    It is currently obsolete and scheduled for removal in a future version.")
  @_Concurrency.MainActor @preconcurrency public var backgroundDecode: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var runLoopMode: Foundation.RunLoop.Mode {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var repeatCount: BanubaUtilities.AnimatedImageView.RepeatCount {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency weak public var delegate: (any BanubaUtilities.AnimatedImageViewDelegate)?
  @_Concurrency.MainActor @preconcurrency public var animator: BanubaUtilities.AnimatedImageView.Animator? {
    get
  }
  @_Concurrency.MainActor @objc override dynamic open var image: BanubaUtilities.KFCrossPlatformImage? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @objc deinit
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isAnimating: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func startAnimating()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func stopAnimating()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func display(_ layer: QuartzCore.CALayer)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func didMoveToWindow()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func didMoveToSuperview()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(image: UIKit.UIImage?)
  @available(iOS 3.0, *)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(image: UIKit.UIImage?, highlightedImage: UIKit.UIImage?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension BanubaUtilities.AnimatedImageView {
  @_hasMissingDesignatedInitializers public class Animator : @unchecked Swift.Sendable {
    final public let maxFrameCount: Swift.Int
    public var currentFrameImage: BanubaUtilities.KFCrossPlatformImage? {
      get
    }
    public var currentFrameDuration: Foundation.TimeInterval {
      get
    }
    public var currentFrameIndex: Swift.Int {
      get
    }
    public var isLastFrame: Swift.Bool {
      get
    }
    public func frame(at index: Swift.Int) -> BanubaUtilities.KFCrossPlatformImage?
    public func duration(at index: Swift.Int) -> Foundation.TimeInterval
    @objc deinit
  }
}
public enum MemoryStorage {
  public class Backend<T> : @unchecked Swift.Sendable where T : BanubaUtilities.CacheCostCalculable {
    public var config: BanubaUtilities.MemoryStorage.Config {
      get
      set
    }
    public init(config: BanubaUtilities.MemoryStorage.Config)
    public func removeExpired()
    public func store(value: T, forKey key: Swift.String, expiration: BanubaUtilities.StorageExpiration? = nil)
    public func value(forKey key: Swift.String, extendingExpiration: BanubaUtilities.ExpirationExtending = .cacheTime) -> T?
    public func isCached(forKey key: Swift.String) -> Swift.Bool
    public func remove(forKey key: Swift.String)
    public func removeAll()
    @objc deinit
  }
}
extension BanubaUtilities.MemoryStorage {
  public struct Config {
    public var totalCostLimit: Swift.Int
    public var countLimit: Swift.Int
    public var expiration: BanubaUtilities.StorageExpiration
    public var cleanInterval: Foundation.TimeInterval
    public var keepWhenEnteringBackground: Swift.Bool
    public init(totalCostLimit: Swift.Int, cleanInterval: Foundation.TimeInterval = 120)
  }
}
@available(*, deprecated, renamed: "AuthenticationChallengeResponsible", message: "Typo. Use `AuthenticationChallengeResponsible` instead")
public typealias AuthenticationChallengeResponsable = BanubaUtilities.AuthenticationChallengeResponsible
public protocol AuthenticationChallengeResponsible : AnyObject {
  func downloader(_ downloader: BanubaUtilities.ImageDownloader, didReceive challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
  func downloader(_ downloader: BanubaUtilities.ImageDownloader, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
}
extension BanubaUtilities.AuthenticationChallengeResponsible {
  public func downloader(_ downloader: BanubaUtilities.ImageDownloader, didReceive challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
  public func downloader(_ downloader: BanubaUtilities.ImageDownloader, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
}
#if compiler(>=5.3) && $RetroactiveAttribute
@available(iOS 14.0, macOS 13.0, *)
extension PhotosUI.PHPickerResult : @unchecked @retroactive Swift.Sendable {
}
#else
@available(iOS 14.0, macOS 13.0, *)
extension PhotosUI.PHPickerResult : @unchecked Swift.Sendable {
}
#endif
@available(iOS 14.0, macOS 13.0, *)
public struct PHPickerResultImageDataProvider : BanubaUtilities.ImageDataProvider {
  public enum PHPickerResultImageDataProviderError : Swift.Error {
    case pickerProviderError(any Swift.Error)
    case invalidImage
  }
  public let pickerResult: PhotosUI.PHPickerResult
  public let contentType: UniformTypeIdentifiers.UTType
  public var cacheKey: Swift.String {
    get
  }
  public init(pickerResult: PhotosUI.PHPickerResult, contentType: UniformTypeIdentifiers.UTType = UTType.image)
  public func data(handler: @escaping @Sendable (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIImage {
  public func image(withBlendMode blendMode: CoreGraphics.CGBlendMode, alpha: CoreFoundation.CGFloat = 1.0, backgroundColor: BanubaUtilities.KFCrossPlatformColor? = nil) -> BanubaUtilities.KFCrossPlatformImage
  public func image(withRadius radius: BanubaUtilities.Radius, fit size: CoreFoundation.CGSize, roundingCorners corners: BanubaUtilities.RectCorner = .all, backgroundColor: BanubaUtilities.KFCrossPlatformColor? = nil) -> BanubaUtilities.KFCrossPlatformImage
  public func image(withRoundRadius radius: CoreFoundation.CGFloat, fit size: CoreFoundation.CGSize, roundingCorners corners: BanubaUtilities.RectCorner = .all, backgroundColor: BanubaUtilities.KFCrossPlatformColor? = nil) -> BanubaUtilities.KFCrossPlatformImage
  public func resize(to size: CoreFoundation.CGSize) -> BanubaUtilities.KFCrossPlatformImage
  public func resize(to targetSize: CoreFoundation.CGSize, for contentMode: BanubaUtilities.ContentMode) -> BanubaUtilities.KFCrossPlatformImage
  public func crop(to size: CoreFoundation.CGSize, anchorOn anchor: CoreFoundation.CGPoint) -> BanubaUtilities.KFCrossPlatformImage
  public func blurred(withRadius radius: CoreFoundation.CGFloat) -> BanubaUtilities.KFCrossPlatformImage
  public func addingBorder(_ border: BanubaUtilities.Border) -> BanubaUtilities.KFCrossPlatformImage
  public func overlaying(with color: BanubaUtilities.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat) -> BanubaUtilities.KFCrossPlatformImage
  public func tinted(with color: BanubaUtilities.KFCrossPlatformColor) -> BanubaUtilities.KFCrossPlatformImage
  public func adjusted(brightness: CoreFoundation.CGFloat, contrast: CoreFoundation.CGFloat, saturation: CoreFoundation.CGFloat, inputEV: CoreFoundation.CGFloat) -> BanubaUtilities.KFCrossPlatformImage
  public func scaled(to scale: CoreFoundation.CGFloat) -> BanubaUtilities.KFCrossPlatformImage
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIImage {
  public var decoded: BanubaUtilities.KFCrossPlatformImage {
    get
  }
  public func decoded(scale: CoreFoundation.CGFloat) -> BanubaUtilities.KFCrossPlatformImage
  public func decoded(on context: CoreGraphics.CGContext) -> BanubaUtilities.KFCrossPlatformImage
}
@available(iOS 14.0, *)
@_Concurrency.MainActor extension BanubaUtilities.KingfisherWrapper where Base : CarPlay.CPListItem {
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: BanubaUtilities.Source?, placeholder: BanubaUtilities.KFCrossPlatformImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any BanubaUtilities.Resource)?, placeholder: BanubaUtilities.KFCrossPlatformImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @_Concurrency.MainActor public func cancelDownloadTask()
}
@_Concurrency.MainActor extension BanubaUtilities.KingfisherWrapper where Base : CarPlay.CPListItem {
  @_Concurrency.MainActor public var taskIdentifier: BanubaUtilities.Source.Identifier.Value? {
    get
  }
}
@_hasMissingDesignatedInitializers public class SessionDataTask : @unchecked Swift.Sendable {
  public typealias CancelToken = Swift.Int
  public var mutableData: Foundation.Data {
    get
  }
  final public let originalURL: Foundation.URL?
  final public let task: Foundation.URLSessionDataTask
  @objc deinit
}
public struct FormatIndicatedCacheSerializer : BanubaUtilities.CacheSerializer {
  public static let png: BanubaUtilities.FormatIndicatedCacheSerializer
  public static let jpeg: BanubaUtilities.FormatIndicatedCacheSerializer
  public static func jpeg(compressionQuality: CoreFoundation.CGFloat) -> BanubaUtilities.FormatIndicatedCacheSerializer
  public static let gif: BanubaUtilities.FormatIndicatedCacheSerializer
  public func data(with image: BanubaUtilities.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  public func image(with data: Foundation.Data, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
@_hasMissingDesignatedInitializers public class RetryContext : @unchecked Swift.Sendable {
  final public let source: BanubaUtilities.Source
  final public let error: BanubaUtilities.KingfisherError
  public var retriedCount: Swift.Int {
    get
    set
  }
  public var userInfo: Any? {
    get
  }
  @objc deinit
}
public enum RetryDecision {
  case retry(userInfo: Any?)
  case stop
}
public protocol RetryStrategy : Swift.Sendable {
  func retry(context: BanubaUtilities.RetryContext, retryHandler: @escaping @Sendable (BanubaUtilities.RetryDecision) -> Swift.Void)
}
public struct DelayRetryStrategy : BanubaUtilities.RetryStrategy {
  public enum Interval : Swift.Sendable {
    case seconds(Foundation.TimeInterval)
    case accumulated(Foundation.TimeInterval)
    case custom(block: @Sendable (_ retriedCount: Swift.Int) -> Foundation.TimeInterval)
  }
  public let maxRetryCount: Swift.Int
  public let retryInterval: BanubaUtilities.DelayRetryStrategy.Interval
  public init(maxRetryCount: Swift.Int, retryInterval: BanubaUtilities.DelayRetryStrategy.Interval = .seconds(3))
  public func retry(context: BanubaUtilities.RetryContext, retryHandler: @escaping @Sendable (BanubaUtilities.RetryDecision) -> Swift.Void)
}
public struct ImageLoadingResult : Swift.Sendable {
  public let image: BanubaUtilities.KFCrossPlatformImage
  public let url: Foundation.URL?
  public let originalData: Foundation.Data
  public init(image: BanubaUtilities.KFCrossPlatformImage, url: Foundation.URL? = nil, originalData: Foundation.Data)
}
@_hasMissingDesignatedInitializers final public class DownloadTask : @unchecked Swift.Sendable {
  final public var sessionTask: BanubaUtilities.SessionDataTask? {
    get
  }
  final public var cancelToken: BanubaUtilities.SessionDataTask.CancelToken? {
    get
  }
  final public func cancel()
  final public var isInitialized: Swift.Bool {
    get
  }
  @objc deinit
}
open class ImageDownloader : @unchecked Swift.Sendable {
  public static let `default`: BanubaUtilities.ImageDownloader
  open var downloadTimeout: Foundation.TimeInterval {
    get
    set
  }
  open var trustedHosts: Swift.Set<Swift.String>?
  open var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
    set
  }
  open var sessionDelegate: BanubaUtilities.SessionDelegate {
    get
    set
  }
  open var requestsUsePipelining: Swift.Bool
  weak open var delegate: (any BanubaUtilities.ImageDownloaderDelegate)?
  weak open var authenticationChallengeResponder: (any BanubaUtilities.AuthenticationChallengeResponsible)?
  public init(name: Swift.String)
  @objc deinit
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: BanubaUtilities.KingfisherParsedOptionsInfo, completionHandler: (@Sendable (Swift.Result<BanubaUtilities.ImageLoadingResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: (@Sendable (Swift.Result<BanubaUtilities.ImageLoadingResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: BanubaUtilities.KingfisherOptionsInfo? = nil, completionHandler: (@Sendable (Swift.Result<BanubaUtilities.ImageLoadingResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask
}
extension BanubaUtilities.ImageDownloader {
  public func downloadImage(with url: Foundation.URL, options: BanubaUtilities.KingfisherParsedOptionsInfo) async throws -> BanubaUtilities.ImageLoadingResult
  public func downloadImage(with url: Foundation.URL, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil) async throws -> BanubaUtilities.ImageLoadingResult
  public func downloadImage(with url: Foundation.URL, options: BanubaUtilities.KingfisherOptionsInfo? = nil) async throws -> BanubaUtilities.ImageLoadingResult
}
extension BanubaUtilities.ImageDownloader {
  public func cancelAll()
  public func cancel(url: Foundation.URL)
}
extension BanubaUtilities.ImageDownloader : BanubaUtilities.AuthenticationChallengeResponsible {
}
extension BanubaUtilities.ImageDownloader : BanubaUtilities.ImageDownloaderDelegate {
}
public protocol ImageDownloadRedirectHandler : Swift.Sendable {
  func handleHTTPRedirection(for task: BanubaUtilities.SessionDataTask, response: Foundation.HTTPURLResponse, newRequest: Foundation.URLRequest) async -> Foundation.URLRequest?
}
public struct AnyRedirectHandler : BanubaUtilities.ImageDownloadRedirectHandler {
  public func handleHTTPRedirection(for task: BanubaUtilities.SessionDataTask, response: Foundation.HTTPURLResponse, newRequest: Foundation.URLRequest) async -> Foundation.URLRequest?
  public init(handle: @escaping @Sendable (BanubaUtilities.SessionDataTask, Foundation.HTTPURLResponse, Foundation.URLRequest, @escaping (Foundation.URLRequest?) -> Swift.Void) -> Swift.Void)
}
public class BanubaCancelHandler {
  public init(handler: @escaping () -> Swift.Void)
  public func cancel()
  @objc deinit
}
public func BNBLocalizedString(_ key: Swift.String) -> Swift.String
@objc public class GalleryConfiguration : ObjectiveC.NSObject {
  public var videoResolution: BanubaUtilities.VideoResolution
  public var galleryItemConfiguration: BanubaUtilities.GalleryItemConfiguration
  public var closeButtonConfiguration: any BanubaUtilities.ImageButtonConfigurationProtocol
  public var albumButtonConfiguration: BanubaUtilities.TextButtonConfiguration
  public var albumArrowIconConfiguration: any BanubaUtilities.ImageConfigurationProtocol
  public var albumTitleImageSpacing: CoreFoundation.CGFloat
  public var collectionInfoHeaderConfiguration: BanubaUtilities.CollectionInfoHeaderConfiguration
  public var galleryItemPreviewViewConfiguration: BanubaUtilities.GalleryItemPreviewViewConfiguration
  public var nextButtonConfiguration: BanubaUtilities.SaveButtonConfiguration
  public var noItemsLabelConfiguration: BanubaUtilities.TextConfiguration
  public var layoutConfiguration: BanubaUtilities.GalleryLayoutConfiguration
  public var galleryTypeButton: BanubaUtilities.TextButtonConfiguration
  public var selectedGalleryTypeButtonBackgroundConfiguration: BanubaUtilities.BackgroundConfiguration
  public var galleryTypesSegmentedControlBackgroundConfiguration: BanubaUtilities.BackgroundConfiguration
  public var galleryTypesSegmentedControlPadding: CoreFoundation.CGSize
  public var isPhotoSequenceAnimationEnabled: Swift.Bool
  public var importItemsLabelConfiguration: BanubaUtilities.TextConfiguration
  public var bottomViewConfiguration: BanubaUtilities.BackgroundConfiguration
  public var visibleTabsInGallery: [BanubaUtilities.GalleryMediaType]
  public var backgroundColor: UIKit.UIColor
  public var maximumSelectedCountFromGallery: Swift.Int
  public var preferredStatusBarStyle: UIKit.UIStatusBarStyle
  public var alertConfiguration: BanubaUtilities.AlertViewConfiguration
  public var autoCutGalleryConfiguration: BanubaUtilities.AutoCutGalleryConfiguration?
  public var selectedItemConfiguration: BanubaUtilities.SelectedGalleryItemConfiguration
  public var shouldHideSelectedItemsBottomViewIfNotItemsSelected: Swift.Bool
  public init(videoResolution: BanubaUtilities.VideoResolution, galleryItemConfiguration: BanubaUtilities.GalleryItemConfiguration, closeButtonConfiguration: any BanubaUtilities.ImageButtonConfigurationProtocol, albumButtonConfiguration: BanubaUtilities.TextButtonConfiguration, albumArrowIconConfiguration: any BanubaUtilities.ImageConfigurationProtocol, albumTitleImageSpacing: CoreFoundation.CGFloat, collectionInfoHeaderConfiguration: BanubaUtilities.CollectionInfoHeaderConfiguration, galleryItemPreviewViewConfiguration: BanubaUtilities.GalleryItemPreviewViewConfiguration, nextButtonConfiguration: BanubaUtilities.SaveButtonConfiguration, noItemsLabelConfiguration: BanubaUtilities.TextConfiguration, layoutConfiguration: BanubaUtilities.GalleryLayoutConfiguration, galleryTypeButton: BanubaUtilities.TextButtonConfiguration, selectedGalleryTypeButtonBackgroundConfiguration: BanubaUtilities.BackgroundConfiguration, galleryTypesSegmentedControlBackgroundConfiguration: BanubaUtilities.BackgroundConfiguration, galleryTypesSegmentedControlPadding: CoreFoundation.CGSize, isPhotoSequenceAnimationEnabled: Swift.Bool, importItemsLabelConfiguration: BanubaUtilities.TextConfiguration, bottomViewConfiguration: BanubaUtilities.BackgroundConfiguration, visibleTabsInGallery: [BanubaUtilities.GalleryMediaType] = [.video, .photo], backgroundColor: UIKit.UIColor, maximumSelectedCountFromGallery: Swift.Int, preferredStatusBarStyle: UIKit.UIStatusBarStyle, alertConfiguration: BanubaUtilities.AlertViewConfiguration, selectedItemConfiguration: BanubaUtilities.SelectedGalleryItemConfiguration, shouldHideSelectedItemsBottomViewIfNotItemsSelected: Swift.Bool, autoCutGalleryConfiguration: BanubaUtilities.AutoCutGalleryConfiguration? = nil)
  public func makeCopy() -> BanubaUtilities.GalleryConfiguration
  @objc deinit
}
@objc public protocol TimeLineDataSourceDelegate {
  @objc optional func timelineDataSource(_ timelineDataSource: any BanubaUtilities.TimeLineDataSource, didPreloadPreview preview: UIKit.UIImage)
  @objc func timelineDataSource(_ timelineDataSource: any BanubaUtilities.TimeLineDataSource, didLoadImage image: UIKit.UIImage, at index: Swift.Int)
  @objc func timelineDataSourceDidFinishThumbnailFetch(_ timelineDataSource: any BanubaUtilities.TimeLineDataSource)
}
@objc public protocol TimeLineDataSource {
  @objc var delegate: (any BanubaUtilities.TimeLineDataSourceDelegate)? { get set }
  @objc var preview: UIKit.UIImage? { get set }
  @objc var previewLoadingHandler: ((_ preview: UIKit.UIImage) -> ())? { get set }
  @objc var duration: CoreMedia.CMTime { get }
  @objc var thumbnails: [UIKit.UIImage] { get }
  @objc var isAllThumbnailsFetched: Swift.Bool { get }
  @objc var thumbnailsCount: Swift.Int { get }
  @objc var thumbnailHeight: CoreFoundation.CGFloat { get }
  @objc func loadPreview(completion: @escaping (UIKit.UIImage?) -> Swift.Void, at second: Swift.Double)
  @objc func getImage(at index: Swift.Int) -> UIKit.UIImage?
  @objc func loadTimelineThumbs(completion: (() -> Swift.Void)?)
  @objc func cancel()
}
@objc public protocol AlbumModel {
  @objc var name: Swift.String? { get set }
  @objc var preview: UIKit.UIImage? { get set }
  @objc var assetCollection: Photos.PHAssetCollection { get }
}
@objc public class AlbumViewModel : ObjectiveC.NSObject, BanubaUtilities.AlbumModel {
  final public let model: BanubaUtilities.ItemCollectionModel
  @objc final public let assetCollection: Photos.PHAssetCollection
  @objc public var name: Swift.String?
  @objc public var preview: UIKit.UIImage?
  public var itemsCount: Swift.Int
  public init(collection: BanubaUtilities.ItemCollectionModel)
  public func requestPreview(handler: @escaping (UIKit.UIImage?) -> Swift.Void)
  @objc deinit
}
public enum DeviceModel : Swift.String, Swift.Codable {
  case iPodTouch5
  case iPodTouch6
  case iPodTouch7
  case iPhone4
  case iPhone4s
  case iPhone5
  case iPhone5c
  case iPhone5s
  case iPhone6
  case iPhone6Plus
  case iPhone6s
  case iPhone6sPlus
  case iPhone7
  case iPhone7Plus
  case iPhoneSE
  case iPhone8
  case iPhone8Plus
  case iPhoneX
  case iPhoneXS
  case iPhoneXSMax
  case iPhoneXR
  case iPhone11
  case iPhone11Pro
  case iPhone11ProMax
  case iPhoneSE2
  case iPhone12
  case iPhone12Mini
  case iPhone12Pro
  case iPhone12ProMax
  case iPhone13
  case iPhone13Mini
  case iPhone13Pro
  case iPhone13ProMax
  case iPhoneSE3
  case iPhone14
  case iPhone14Plus
  case iPhone14Pro
  case iPhone14ProMax
  case iPad2
  case iPad3
  case iPad4
  case iPadAir
  case iPadAir2
  case iPad5
  case iPad6
  case iPadAir3
  case iPad7
  case iPad8
  case iPad9
  case iPad10
  case iPadAir4
  case iPadAir5
  case iPadMini
  case iPadMini2
  case iPadMini3
  case iPadMini4
  case iPadMini5
  case iPadMini6
  case iPadPro9Inch
  case iPadPro12Inch
  case iPadPro12Inch2
  case iPadPro10Inch
  case iPadPro11Inch
  case iPadPro12Inch3
  case iPadPro11Inch2
  case iPadPro12Inch4
  case iPadPro11Inch3
  case iPadPro12Inch5
  case iPadPro11Inch4
  case iPadPro12Inch6
  case simulator
  case unknown
  public static var current: BanubaUtilities.DeviceModel {
    get
  }
  public static var identifier: Swift.String
  public static func mapToDevice(identifier: Swift.String) -> BanubaUtilities.DeviceModel
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct SaveButtonConfiguration {
  public var textConfiguration: BanubaUtilities.TextConfiguration
  public var inactiveTextConfiguration: BanubaUtilities.TextConfiguration
  public var text: Swift.String
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var cornerRadius: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var inactiveBackgroundColor: UIKit.UIColor
  public var shadowConfiguration: BanubaUtilities.ShadowConfiguration?
  public init(textConfiguration: BanubaUtilities.TextConfiguration, inactiveTextConfiguration: BanubaUtilities.TextConfiguration, text: Swift.String, width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat, cornerRadius: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, inactiveBackgroundColor: UIKit.UIColor, shadowConfiguration: BanubaUtilities.ShadowConfiguration?)
}
extension Swift.Encodable {
  public func toDictionary(_ encoder: Foundation.JSONEncoder = JSONEncoder()) throws -> [Swift.String : Any]
  public func toString() throws -> Swift.String
}
extension UIKit.UILabel {
  @_Concurrency.MainActor @preconcurrency public func applyConfiguration(_ configuration: BanubaUtilities.TextConfiguration, with text: Swift.String)
}
extension CoreFoundation.CGPoint {
  public mutating func transformToGradientSpace()
  public func oppositePoint() -> CoreFoundation.CGPoint
  public static func gradientPointForAngle(_ angle: CoreFoundation.CGFloat) -> CoreFoundation.CGPoint
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class ActivityIndicatorView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public var spinCircleLayer: QuartzCore.CAShapeLayer
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var bounds: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency public var configuration: BanubaUtilities.SmallActivityIndicatorConfiguration? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency public func startAnimating()
  @_Concurrency.MainActor @preconcurrency public func stopAnimating()
  @objc deinit
}
public protocol EffectSelectionViewControllerDelegate : AnyObject {
  func effectSelectionViewController(viewController: any BanubaUtilities.EffectSelectionViewController, didSelectFile url: Foundation.URL, isEditable: Swift.Bool, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID)
  func effectSelectionViewControllerDidCancel(viewController: any BanubaUtilities.EffectSelectionViewController)
}
public protocol EffectSelectionViewController : UIKit.UIViewController {
  var effectSelectionDelegate: (any BanubaUtilities.EffectSelectionViewControllerDelegate)? { get set }
}
@objc public class VideoTimeLineCollectionViewHandler : ObjectiveC.NSObject {
  final public let collectionView: UIKit.UICollectionView
  final public let timeLineDataSource: any BanubaUtilities.TimeLineDataSource
  final public let cornerRadius: CoreFoundation.CGFloat
  public init(collectionView: UIKit.UICollectionView, timeLineDataSource: any BanubaUtilities.TimeLineDataSource, cornerRadius: CoreFoundation.CGFloat, isScrollEnabled: Swift.Bool = false)
  @objc deinit
}
extension BanubaUtilities.VideoTimeLineCollectionViewHandler {
  public func applyContentInset(appliedWidth: CoreFoundation.CGFloat, shouldMirrorHorizontalInset: Swift.Bool = false, cursorOffset: CoreFoundation.CGFloat? = nil)
  public func applyContentOffset(_ offset: CoreFoundation.CGPoint)
  public func cellSize() -> CoreFoundation.CGSize
  public func getImage(at seconds: Foundation.TimeInterval) -> UIKit.UIImage?
}
extension BanubaUtilities.VideoTimeLineCollectionViewHandler : BanubaUtilities.TimeLineDataSourceDelegate {
  @objc dynamic public func timelineDataSource(_ timelineDataSource: any BanubaUtilities.TimeLineDataSource, didPreloadPreview preview: UIKit.UIImage)
  @objc dynamic public func timelineDataSource(_ timelineDataSource: any BanubaUtilities.TimeLineDataSource, didLoadImage image: UIKit.UIImage, at index: Swift.Int)
  @objc dynamic public func timelineDataSourceDidFinishThumbnailFetch(_ timelineDataSource: any BanubaUtilities.TimeLineDataSource)
}
extension BanubaUtilities.VideoTimeLineCollectionViewHandler : UIKit.UICollectionViewDataSource, UIKit.UICollectionViewDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, willDisplay cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath)
}
extension BanubaUtilities.VideoTimeLineCollectionViewHandler : UIKit.UICollectionViewDelegateFlowLayout {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, sizeForItemAt indexPath: Foundation.IndexPath) -> CoreFoundation.CGSize
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Swift.Int) -> CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, minimumLineSpacingForSectionAt section: Swift.Int) -> CoreFoundation.CGFloat
}
@_hasMissingDesignatedInitializers public class ConnectionListener {
  final public let onConnectionChanged: ((BanubaUtilities.Connection) -> ())
  @objc deinit
}
public protocol ReachabilityServicing {
  var currentConnection: BanubaUtilities.Connection { get }
  var isInternetAvailable: Swift.Bool { get }
  func listenConnection(onConnectionChanged: @escaping ((BanubaUtilities.Connection) -> ())) -> BanubaUtilities.ConnectionListener
  func stopListenConnection(for connectionListener: BanubaUtilities.ConnectionListener)
}
public struct ReachabilityServiceBuilder {
  public static func build() -> (any BanubaUtilities.ReachabilityServicing)?
}
public struct MediaTrackTimeRange : Swift.Codable {
  public let startTime: CoreMedia.CMTime
  public let playingTimeRange: CoreMedia.CMTimeRange
  public init(startTime: CoreMedia.CMTime, playingTimeRange: CoreMedia.CMTimeRange)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public class MediaTrack : Swift.Codable {
  final public let uuid: Foundation.UUID
  final public let url: Foundation.URL
  final public let coverURL: Foundation.URL?
  public var timeRange: BanubaUtilities.MediaTrackTimeRange
  final public let title: Swift.String?
  final public let additionalTitle: Swift.String?
  final public let isEditable: Swift.Bool
  public var id: CoreMedia.CMPersistentTrackID?
  public init(uuid: Foundation.UUID, id: CoreMedia.CMPersistentTrackID?, url: Foundation.URL, coverURL: Foundation.URL?, timeRange: BanubaUtilities.MediaTrackTimeRange, isEditable: Swift.Bool, title: Swift.String? = nil, additionalTitle: Swift.String? = nil)
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Foundation.FileManager {
  public func replaceWithCopyOfFile(at: Foundation.URL, with: Foundation.URL)
}
@objc @_inheritsConvenienceInitializers open class BanubaAsyncOperation : Foundation.Operation, @unchecked Swift.Sendable {
  @objc override dynamic open var isReady: Swift.Bool {
    @objc get
  }
  @objc final override public var isExecuting: Swift.Bool {
    @objc get
  }
  @objc final override public var isFinished: Swift.Bool {
    @objc get
  }
  @objc final override public var isAsynchronous: Swift.Bool {
    @objc get
  }
  @objc override dynamic open class func keyPathsForValuesAffectingValue(forKey key: Swift.String) -> Swift.Set<Swift.String>
  @objc final override public func start()
  @objc override dynamic open func main()
  final public func finish()
  @objc override dynamic public init()
  @objc deinit
}
public enum BackgroundViewStyle : Swift.Equatable {
  case blur(style: UIKit.UIBlurEffect.Style)
  case dim
  case none
  public static func == (a: BanubaUtilities.BackgroundViewStyle, b: BanubaUtilities.BackgroundViewStyle) -> Swift.Bool
}
public enum TransitionType : Swift.String, Swift.Codable, Swift.CaseIterable {
  case normal
  case whipDown
  case whipUp
  case whipRight
  case whipLeft
  case scrollDown
  case scrollUp
  case scrollRight
  case scrollLeft
  case spinRight
  case fade
  case blink
  case stretching2
  case infinityPlus
  case infinityMinus
  case retractionPlus
  case retractionMinus
  case stretchLeft
  case stretchRight
  case rotationPlus
  case rotationMinus
  case scrollMirroredDown
  case scrollMirroredUp
  case scrollMirroredRight
  case scrollMirroredLeft
  case fadingFromWhite
  case fromDark
  case intoDark
  public static func withId(_ id: Swift.Int) -> BanubaUtilities.TransitionType?
  public var id: Swift.Int {
    get
  }
  public var displayName: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [BanubaUtilities.TransitionType]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [BanubaUtilities.TransitionType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
extension Dispatch.DispatchQueue {
  public static func checkAndPerformOnMainThreadAsync(_ block: @escaping () -> Swift.Void)
}
public struct SelectedGalleryItemConfiguration {
  public var cornerRadius: CoreFoundation.CGFloat
  public init(cornerRadius: CoreFoundation.CGFloat)
}
extension Swift.String {
  public func height(forFont font: UIKit.UIFont) -> CoreFoundation.CGFloat
  public func width(forFont font: UIKit.UIFont) -> CoreFoundation.CGFloat
}
extension Swift.Double {
  public func rounded(toPlaces places: Swift.Int, rule: Swift.FloatingPointRoundingRule? = nil) -> Swift.Double
}
@objc public class AlbumsConfiguration : ObjectiveC.NSObject {
  public var textButton: BanubaUtilities.TextButtonConfiguration
  public var arrowIconConfiguration: any BanubaUtilities.ImageConfigurationProtocol
  public var albumTitleImageSpacing: CoreFoundation.CGFloat
  public var backButton: BanubaUtilities.BackButtonConfiguration
  public var albumItemConfiguration: BanubaUtilities.AlbumItemConfiguration
  public var backgroundColor: UIKit.UIColor
  public init(textButton: BanubaUtilities.TextButtonConfiguration, arrowIconConfiguration: any BanubaUtilities.ImageConfigurationProtocol, albumTitleImageSpacing: CoreFoundation.CGFloat, backButton: BanubaUtilities.BackButtonConfiguration, albumItemConfiguration: BanubaUtilities.AlbumItemConfiguration, backgroundColor: UIKit.UIColor)
  @objc deinit
}
@objc public class AlbumItemConfiguration : ObjectiveC.NSObject {
  public var titleConfiguration: BanubaUtilities.TextConfiguration
  public var numberOfAlbumItemsConfiguration: BanubaUtilities.TextConfiguration
  public var coverCornerRadius: CoreFoundation.CGFloat
  public init(titleConfiguration: BanubaUtilities.TextConfiguration, numberOfAlbumItemsConfiguration: BanubaUtilities.TextConfiguration, coverCornerRadius: CoreFoundation.CGFloat)
  @objc deinit
}
public struct PlayerControlConfiguration {
  public var playButtonImageName: Swift.String
  public var pauseButtonImageName: Swift.String
  public var tintColor: UIKit.UIColor?
  public var playImage: UIKit.UIImage?
  public var pauseImage: UIKit.UIImage?
  public init(playButtonImageName: Swift.String, pauseButtonImageName: Swift.String, tintColor: UIKit.UIColor? = nil)
  public init(playImage: UIKit.UIImage?, pauseImage: UIKit.UIImage?)
}
public protocol ExternalLogListener {
  func log(message: Swift.String)
  func log(error: Swift.String)
}
@_hasMissingDesignatedInitializers open class Logger {
  public static var externalListener: (any BanubaUtilities.ExternalLogListener)?
  open class func logError(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "", file: Swift.String = #fileID, line: Swift.Int = #line)
  open class func logDebug(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "", file: Swift.String = #fileID, line: Swift.Int = #line)
  open class func logInfo(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "", file: Swift.String = #fileID, line: Swift.Int = #line)
  open class func logFault(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "", file: Swift.String = #fileID, line: Swift.Int = #line)
  open class func logDefault(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "", file: Swift.String = #fileID, line: Swift.Int = #line)
  @objc deinit
}
@_Concurrency.MainActor @preconcurrency public struct TTSwiftUISegmentedControl : SwiftUI.UIViewRepresentable {
  @_Concurrency.MainActor @preconcurrency public init(titles: [BanubaUtilities.TTSegmentedControlTitle], selectedIndex: SwiftUICore.Binding<Swift.Int?>? = .constant(nil))
  @_Concurrency.MainActor @preconcurrency public func makeUIView(context: BanubaUtilities.TTSwiftUISegmentedControl.Context) -> UIKit.UIView
  @_Concurrency.MainActor @preconcurrency public func updateUIView(_ view: UIKit.UIView, context: BanubaUtilities.TTSwiftUISegmentedControl.Context)
  @_Concurrency.MainActor @preconcurrency public func makeCoordinator() -> BanubaUtilities.TTSwiftUISegmentedControl.Coordinator
  @_hasMissingDesignatedInitializers final public class Coordinator : BanubaUtilities.TTSegmentedControlDelegate {
    final public func segmentedViewDidBegin(_ view: BanubaUtilities.TTSegmentedControl)
    final public func segmentedView(_ view: BanubaUtilities.TTSegmentedControl, didDragAt index: Swift.Int)
    final public func segmentedView(_ view: BanubaUtilities.TTSegmentedControl, didEndAt index: Swift.Int)
    @objc deinit
  }
  public typealias Body = Swift.Never
  public typealias UIViewType = UIKit.UIView
}
extension BanubaUtilities.TTSwiftUISegmentedControl {
  @_Concurrency.MainActor @preconcurrency public func titleDistribution(_ distribution: BanubaUtilities.TTSegmentedControl.TitleDistribution) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func selectionViewPadding(_ padding: CoreFoundation.CGSize) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func isDragEnabled(_ value: Swift.Bool) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func animationOptions(_ options: BanubaUtilities.TTSegmentedControlAnimationOption?) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func isSizeAdjustEnabled(_ value: Swift.Bool) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func containerColorType(_ colorType: BanubaUtilities.TTSegmentedControl.ColorType) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func selectionViewColorType(_ colorType: BanubaUtilities.TTSegmentedControl.ColorType) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func switchSecondSelectionViewColorType(_ colorType: BanubaUtilities.TTSegmentedControl.ColorType?) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func selectionViewShadow(_ shadow: BanubaUtilities.TTSegmentedControlShadow?) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func selectionViewInnerShadow(_ shadow: BanubaUtilities.TTSegmentedControlShadow?) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func selectionViewBorder(_ border: BanubaUtilities.TTSegmentedControlBorder?) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func selectionViewFillType(_ type: BanubaUtilities.TTSegmentedControl.SelectionViewFillType) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func bounceAnimationOptions(_ options: BanubaUtilities.TTSegmentedControlBounceOptions?) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func cornerRadius(_ type: BanubaUtilities.TTSegmentedControl.CornerRadius) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func cornerCurve(_ cornerCurve: QuartzCore.CALayerCornerCurve) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func isSwitchBehaviorEnabled(_ value: Swift.Bool) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func didBeginTouch(_ body: (() -> Swift.Void)?) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func didDragOverItemAtIndex(_ body: ((Swift.Int) -> Swift.Void)?) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func didEndTouchAtIndex(_ body: ((Swift.Int) -> Swift.Void)?) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func containerViewInnerShadow(_ shadow: BanubaUtilities.TTSegmentedControlShadow?) -> BanubaUtilities.TTSwiftUISegmentedControl
  @_Concurrency.MainActor @preconcurrency public func containerViewBorder(_ border: BanubaUtilities.TTSegmentedControlBorder?) -> BanubaUtilities.TTSwiftUISegmentedControl
}
public struct AlertViewConfiguration {
  public var backgroundColor: UIKit.UIColor
  public var alertBackgroundConfiguration: BanubaUtilities.BackgroundConfiguration
  public var resetButtonTextConfig: BanubaUtilities.TextButtonConfiguration
  public var resetCancelTextConfig: BanubaUtilities.TextButtonConfiguration
  public var additionalButtonTextConfig: BanubaUtilities.TextButtonConfiguration
  public var refuseButtonTextConfig: BanubaUtilities.TextButtonConfiguration
  public var agreeButtonTextConfig: BanubaUtilities.TextButtonConfiguration
  public var titleTextConfig: BanubaUtilities.TextConfiguration
  public var messageTextConfig: BanubaUtilities.TextConfiguration
  public var spacingBetweenTitleAndMessageLabels: CoreFoundation.CGFloat
  public var titleAndMessageInsets: UIKit.UIEdgeInsets
  public var preferredStatusBarStyle: UIKit.UIStatusBarStyle
  public var width: CoreFoundation.CGFloat
  public init(backgroundColor: UIKit.UIColor, alertBackgroundConfiguration: BanubaUtilities.BackgroundConfiguration, resetButtonTextConfig: BanubaUtilities.TextButtonConfiguration, resetCancelTextConfig: BanubaUtilities.TextButtonConfiguration, refuseButtonTextConfig: BanubaUtilities.TextButtonConfiguration, agreeButtonTextConfig: BanubaUtilities.TextButtonConfiguration, additionalButtonTextConfig: BanubaUtilities.TextButtonConfiguration, titleTextConfig: BanubaUtilities.TextConfiguration, messageTextConfig: BanubaUtilities.TextConfiguration, spacingBetweenTitleAndMessageLabels: CoreFoundation.CGFloat, titleAndMessageInsets: UIKit.UIEdgeInsets, preferredStatusBarStyle: UIKit.UIStatusBarStyle, width: CoreFoundation.CGFloat = 312)
}
public struct GalleryItemConfiguration {
  public var orderNumberBackgroudColor: UIKit.UIColor
  public var orderNumberSelectedBackgroudColor: UIKit.UIColor
  public var orderNumberTitleColor: UIKit.UIColor
  public var orderNumberTitleFont: UIKit.UIFont
  public var orderNumberBorderWidth: CoreFoundation.CGFloat
  public var orderNumberSelectedBorderWidth: CoreFoundation.CGFloat
  public var orderNumberBorderColor: UIKit.UIColor
  public var orderNumberHeight: CoreFoundation.CGFloat
  public var durationLabelConfiguration: BanubaUtilities.TextConfiguration
  public var durationLabelBackgroundConfiguration: BanubaUtilities.BackgroundConfiguration
  public var durationLabelBackgroundMode: BanubaUtilities.BackgroundMode
  public enum DurationLabelAlignment {
    case left
    case right
    public static func == (a: BanubaUtilities.GalleryItemConfiguration.DurationLabelAlignment, b: BanubaUtilities.GalleryItemConfiguration.DurationLabelAlignment) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var durationLabelAlignment: BanubaUtilities.GalleryItemConfiguration.DurationLabelAlignment
  public var activityIndicatorConfiguration: BanubaUtilities.SmallActivityIndicatorConfiguration
  public var cornerRadius: CoreFoundation.CGFloat
  @frozen public enum SelectedOverlay {
    case none
    case color(UIKit.UIColor)
  }
  public var selectedOverlay: BanubaUtilities.GalleryItemConfiguration.SelectedOverlay
  public init(orderNumberBackgroudColor: UIKit.UIColor, orderNumberSelectedBackgroudColor: UIKit.UIColor, orderNumberTitleColor: UIKit.UIColor, orderNumberTitleFont: UIKit.UIFont, orderNumberBorderWidth: CoreFoundation.CGFloat, orderNumberSelectedBorderWidth: CoreFoundation.CGFloat, orderNumberBorderColor: UIKit.UIColor, orderNumberHeight: CoreFoundation.CGFloat, durationLabelConfiguration: BanubaUtilities.TextConfiguration, durationLabelBackgroundConfiguration: BanubaUtilities.BackgroundConfiguration, durationLabelBackgroundMode: BanubaUtilities.BackgroundMode, durationLabelAlignment: BanubaUtilities.GalleryItemConfiguration.DurationLabelAlignment, activityIndicatorConfiguration: BanubaUtilities.SmallActivityIndicatorConfiguration, cornerRadius: CoreFoundation.CGFloat, selectedOverlay: BanubaUtilities.GalleryItemConfiguration.SelectedOverlay)
}
@frozen public enum BackgroundMode {
  case color
  case blur(UIKit.UIVisualEffect)
}
public struct TTSegmentedControlBounceOptions {
  public let springDamping: CoreFoundation.CGFloat
  public let springInitialVelocity: CoreFoundation.CGFloat
  public init(springDamping: CoreFoundation.CGFloat = 0.7, springInitialVelocity: CoreFoundation.CGFloat = 0.2)
}
public struct TTSegmentedControlAnimationOption {
  public let duration: Foundation.TimeInterval
  public let options: UIKit.UIView.AnimationOptions
  public init(duration: Foundation.TimeInterval = 0.3, options: UIKit.UIView.AnimationOptions = .curveEaseInOut)
}
public struct TTSegmentedControlBorder {
  public let color: UIKit.UIColor
  public let lineWidth: CoreFoundation.CGFloat
  public init(color: UIKit.UIColor, lineWidth: CoreFoundation.CGFloat = 1)
}
public struct TTSegmentedControlShadow {
  public let color: UIKit.UIColor
  public let offset: CoreFoundation.CGSize
  public let innerOffset: CoreFoundation.CGSize
  public let opacity: Swift.Float
  public let radius: CoreFoundation.CGFloat
  public init(color: UIKit.UIColor = .black, offset: CoreFoundation.CGSize = .init(width: 0, height: 1), innerOffset: CoreFoundation.CGSize = .init(width: -1, height: -1), opacity: Swift.Float = 0.6, radius: CoreFoundation.CGFloat = 3.0)
}
public struct TTSegmentedControlTitle {
  public let text: Swift.String?
  public let defaultColor: UIKit.UIColor
  public let defaultFont: UIKit.UIFont
  public let defaultAttributedText: Foundation.NSAttributedString?
  public let defaultImage: UIKit.UIImage?
  public let selectedColor: UIKit.UIColor
  public let selectedFont: UIKit.UIFont
  public let selectedAttributedText: Foundation.NSAttributedString?
  public let selectedImage: UIKit.UIImage?
  public let imageSize: CoreFoundation.CGSize?
  public let imagePosition: BanubaUtilities.TTSegmentedControlTitle.ImagePosition
  public let spaceBetweenTextAndImage: CoreFoundation.CGFloat
  public init(text: Swift.String? = nil, defaultColor: UIKit.UIColor = .black, defaultFont: UIKit.UIFont = .systemFont(ofSize: 12), defaultImage: UIKit.UIImage? = nil, selectedColor: UIKit.UIColor = .white, selectedFont: UIKit.UIFont = .systemFont(ofSize: 12), selectedImage: UIKit.UIImage? = nil, imageSize: CoreFoundation.CGSize? = nil, imagePosition: BanubaUtilities.TTSegmentedControlTitle.ImagePosition = .right, spaceBetweenTextAndImage: CoreFoundation.CGFloat = 5)
  public init(defaultAttributedText: Foundation.NSAttributedString, defaultImage: UIKit.UIImage? = nil, selectedAttributedText: Foundation.NSAttributedString, selectedImage: UIKit.UIImage? = nil, imageSize: CoreFoundation.CGSize? = nil, imagePosition: BanubaUtilities.TTSegmentedControlTitle.ImagePosition = .right, spaceBetweenTextAndImage: CoreFoundation.CGFloat = 5)
}
extension BanubaUtilities.TTSegmentedControlTitle {
  public enum ImagePosition {
    case left
    case right
    case top
    case bottom
    public static func == (a: BanubaUtilities.TTSegmentedControlTitle.ImagePosition, b: BanubaUtilities.TTSegmentedControlTitle.ImagePosition) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class RTLCollectionViewFlowLayout : UIKit.UICollectionViewFlowLayout {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var flipsHorizontallyInOppositeLayoutDirection: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public struct TTSegmentedControlGradient {
  public let locations: [Foundation.NSNumber]?
  public let startPoint: CoreFoundation.CGPoint
  public let endPoint: CoreFoundation.CGPoint
  public let colors: [UIKit.UIColor]
  public init(locations: [Foundation.NSNumber]? = nil, startPoint: CoreFoundation.CGPoint = CGPoint(x: 0.5, y: 0.0), endPoint: CoreFoundation.CGPoint = CGPoint(x: 0.5, y: 1.0), colors: [UIKit.UIColor] = [.yellow, .purple])
}
extension UIKit.UIStackView {
  @_Concurrency.MainActor @preconcurrency public func addArrangedSubviews(_ subviews: [UIKit.UIView])
  @_Concurrency.MainActor @preconcurrency public func removeAllArrangedSubviews()
}
public protocol AudioItem {
  var uuid: Foundation.UUID { get }
  var url: Foundation.URL { get }
  var coverURL: Foundation.URL? { get }
  var title: Swift.String? { get set }
  var additionalTitle: Swift.String? { get set }
  var isEditable: Swift.Bool { get set }
}
extension CoreFoundation.CGFloat {
  public var gradientPoints: (CoreFoundation.CGPoint, CoreFoundation.CGPoint) {
    get
  }
}
public struct ItemCollectionModel {
  public var assetCollection: Photos.PHAssetCollection
  public var previewAsset: Photos.PHAsset?
}
public protocol GalleryAdapter : AnyObject {
  var changesHandler: BanubaUtilities.GalleryManager.ChangesHandler? { get set }
  func checkAccessStatus(completion: @escaping (Swift.Bool) -> ())
  func getPreviewImageForGallery(completion: @escaping (UIKit.UIImage?) -> ())
  func fetchMediaAsset(from album: Photos.PHAssetCollection?, type: Photos.PHAssetMediaType, limit: Swift.Int?) -> [any BanubaUtilities.GalleryItem]
  func fetchMediaAsset(from album: Photos.PHAssetCollection?, limit: Swift.Int?) -> [any BanubaUtilities.GalleryItem]
  func fetchSmartAlbums() -> [BanubaUtilities.ItemCollectionModel]
  func register()
}
extension BanubaUtilities.GalleryAdapter {
  public func fetchMediaAsset(from album: Photos.PHAssetCollection?, type: Photos.PHAssetMediaType, limit: Swift.Int? = nil) -> [any BanubaUtilities.GalleryItem]
}
@objc final public class GalleryManager : ObjectiveC.NSObject, BanubaUtilities.GalleryAdapter {
  final public let videoResolution: BanubaUtilities.VideoResolution
  final public let minimumDurationFromGallery: Foundation.TimeInterval
  final public var changesHandler: BanubaUtilities.GalleryManager.ChangesHandler?
  public typealias ChangesHandler = ((Photos.PHChange, [Photos.PHAsset]?, [Photos.PHAsset]?) -> Swift.Void)
  final public var authorizationStatus: Photos.PHAuthorizationStatus {
    get
  }
  final public var isCollectionsObserve: Swift.Bool
  required public init(isManuallyRegister: Swift.Bool, videoResolution: BanubaUtilities.VideoResolution, minimumDurationFromGallery: Foundation.TimeInterval)
  final public func register()
  final public func getPreviewImageForGallery(completion: @escaping (UIKit.UIImage?) -> ())
  final public func fetchAssets(in collection: Photos.PHAssetCollection, options: Photos.PHFetchOptions) -> Photos.PHFetchResult<Photos.PHAsset>
  @objc deinit
}
extension BanubaUtilities.GalleryManager : Photos.PHPhotoLibraryChangeObserver {
  @objc final public func photoLibraryDidChange(_ changeInstance: Photos.PHChange)
}
extension BanubaUtilities.GalleryManager {
  final public func fetchCollections(isNeedToStoreAssets: Swift.Bool) -> [BanubaUtilities.ItemCollectionModel]
  final public func fetchSmartAlbums() -> [BanubaUtilities.ItemCollectionModel]
  final public func fetchPhotoAndVideoAssets() -> [BanubaUtilities.BanubaGalleryItem]
  final public func fetchMediaAsset(from album: Photos.PHAssetCollection? = nil, type: Photos.PHAssetMediaType, limit: Swift.Int?) -> [any BanubaUtilities.GalleryItem]
  final public func fetchMediaAsset(from album: Photos.PHAssetCollection?, limit: Swift.Int?) -> [any BanubaUtilities.GalleryItem]
  final public func checkAccessStatus(completion: @escaping (Swift.Bool) -> ())
}
extension BanubaUtilities.GalleryManager {
  public static func requestAccessIfNeeded(completion: @escaping (Swift.Bool) -> ())
}
@_hasMissingDesignatedInitializers final public class DurationFormatter {
  public static let shared: BanubaUtilities.DurationFormatter
  final public func format(_ time: Foundation.TimeInterval, isHoursInFullFormat: Swift.Bool = false, isMinutesInFullFormat: Swift.Bool = false, isMillisecondsEnabled: Swift.Bool = true) -> Swift.String
  @objc deinit
}
@objc public protocol GalleryViewControllerDelegate {
  @objc func galleryViewController(_ controller: BanubaUtilities.GalleryViewController, didStartExportWith progressHandler: BanubaUtilities.ProgressHandler)
  @objc func galleryViewController(_ controller: BanubaUtilities.GalleryViewController, didEndExportWith error: (any Swift.Error)?, hideProgressViewCompletion: @escaping () -> Swift.Void)
  @objc func galleryViewControllerDidClose(_ controller: BanubaUtilities.GalleryViewController)
  @objc func galleryViewControllerDone(_ controller: BanubaUtilities.GalleryViewController, withGalleryItems items: [any BanubaUtilities.GalleryItem])
  @objc func galleryViewControllerDoneForAutoCut(_ controller: BanubaUtilities.GalleryViewController, withGalleryItems items: [any BanubaUtilities.GalleryItem])
  @objc func galleryViewController(_ controller: BanubaUtilities.GalleryViewController, presentMessage message: Swift.String)
  @objc func galleryViewControllerDidRequestCamera(_ controller: BanubaUtilities.GalleryViewController)
}
@objc public enum GalleryMediaType : Swift.Int, Swift.CaseIterable {
  case all = 0
  case video
  case photo
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [BanubaUtilities.GalleryMediaType]
  public typealias RawValue = Swift.Int
  nonisolated public static var allCases: [BanubaUtilities.GalleryMediaType] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@objc public class GallerySelectionBehaviour : ObjectiveC.NSObject {
  final public let maximumSelectedCount: Swift.Int
  final public let selectedItemsCount: Swift.Int?
  final public let isMultiselectModeEnabled: Swift.Bool
  final public let minimumGalleryVideoDuration: Foundation.TimeInterval
  final public let allowedMediaTypes: [BanubaUtilities.GalleryMediaType]
  final public let slideshowDuration: Foundation.TimeInterval
  final public let isCameraCellEnabled: Swift.Bool
  public init(maximumSelectedCount: Swift.Int, selectedItemsCount: Swift.Int? = nil, isMultiselectModeEnabled: Swift.Bool, minimumGalleryVideoDuration: Foundation.TimeInterval, allowedMediaTypes: [BanubaUtilities.GalleryMediaType], slideshowDuration: Foundation.TimeInterval, isCameraCellEnabled: Swift.Bool = false)
  public var isAdditionalItemsRequired: Swift.Bool {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor @preconcurrency open class GalleryViewController : UIKit.UIViewController, BanubaUtilities.AlertPresentable {
  @_Concurrency.MainActor @preconcurrency weak open var delegate: (any BanubaUtilities.GalleryViewControllerDelegate)?
  @_Concurrency.MainActor @preconcurrency open var configuration: BanubaUtilities.GalleryConfiguration?
  @_Concurrency.MainActor @preconcurrency open var selectionBehaviour: BanubaUtilities.GallerySelectionBehaviour?
  @_Concurrency.MainActor @preconcurrency open func useAlbum(_ albumView: any BanubaUtilities.AlbumModel)
  @_Concurrency.MainActor @preconcurrency open func cancelExport()
  @_Concurrency.MainActor @preconcurrency open func retryExport()
  @_Concurrency.MainActor @preconcurrency open func getAlertViewController() -> BanubaUtilities.AlertViewController?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor @preconcurrency open class AlbumsViewController : UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency weak open var delegate: (any BanubaUtilities.AlbumsViewControllerDelegate)?
  @_Concurrency.MainActor @preconcurrency open var configuration: BanubaUtilities.AlbumsConfiguration?
  @_Concurrency.MainActor @preconcurrency open var selectedAlbum: (any BanubaUtilities.AlbumModel)?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc public protocol AlbumsViewControllerDelegate {
  @objc func albumsViewController(_ controller: BanubaUtilities.AlbumsViewController, didSelect album: any BanubaUtilities.AlbumModel)
  @objc func albumsViewControllerDidClose(_ controller: BanubaUtilities.AlbumsViewController)
}
@_inheritsConvenienceInitializers @objc public class ProgressHandler : ObjectiveC.NSObject {
  public var callback: ((Swift.Double) -> Swift.Void)?
  @objc override dynamic public init()
  @objc deinit
}
public struct CollectionInfoHeaderConfiguration {
  public var textConfiguration: BanubaUtilities.TextConfiguration
  public var hideButtonConfiguration: any BanubaUtilities.ImageButtonConfigurationProtocol
  public var height: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var underlinedTextColor: UIKit.UIColor
  public var underlinedTextFont: UIKit.UIFont
  public init(textConfiguration: BanubaUtilities.TextConfiguration, hideButtonConfiguration: any BanubaUtilities.ImageButtonConfigurationProtocol, height: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, underlinedTextColor: UIKit.UIColor, underlinedTextFont: UIKit.UIFont = .systemFont(ofSize: 13.0))
}
extension Swift.CaseIterable where Self : Swift.Equatable {
  public var next: Self {
    get
  }
}
public struct GalleryItemPreviewViewConfiguration {
  public var backgroundViewBlurStyle: UIKit.UIBlurEffect.Style
  public var selectionButtonView: BanubaUtilities.BackgroundConfiguration
  public var selectionButtonSelectText: BanubaUtilities.TextConfiguration
  public var selectionButtonDeselectText: BanubaUtilities.TextConfiguration
  public var selectionButtonSelectImageName: Swift.String
  public var selectionButtonDeselectImageName: Swift.String
  public var selectionButtonImageLeftInset: CoreFoundation.CGFloat
  public var selectionButtonImageRightInset: CoreFoundation.CGFloat
  public var previewContainerView: BanubaUtilities.BackgroundConfiguration
  public init(backgroundViewBlurStyle: UIKit.UIBlurEffect.Style, selectionButtonView: BanubaUtilities.BackgroundConfiguration, selectionButtonSelectText: BanubaUtilities.TextConfiguration, selectionButtonDeselectText: BanubaUtilities.TextConfiguration, selectionButtonSelectImageName: Swift.String, selectionButtonDeselectImageName: Swift.String, selectionButtonImageLeftInset: CoreFoundation.CGFloat = 20.0, selectionButtonImageRightInset: CoreFoundation.CGFloat = 4.0, previewContainerView: BanubaUtilities.BackgroundConfiguration)
}
public enum FileExtension {
  public enum Video : Swift.String {
    case mp4
    case mov
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension Swift.Int32 {
  public static let `default`: CoreMedia.CMTimeScale
}
public struct DeviceVibrateManager {
  public static func vibrate(withPower power: UIKit.UIImpactFeedbackGenerator.FeedbackStyle)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class CircularProgressView : UIKit.UIView, BanubaUtilities.ProgressAnimatableView {
  @_Concurrency.MainActor @preconcurrency public var progressColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var shadowColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var progress: Swift.Float {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var shadowLineWidth: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public var progressLineWidth: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func layoutSublayers(of layer: QuartzCore.CALayer)
  @_Concurrency.MainActor @preconcurrency public func resetProgress()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc public protocol ImageConfigurationProtocol {
  @objc var image: UIKit.UIImage? { get }
  @objc var tintColor: UIKit.UIColor? { get }
}
public class BanubaImageConfiguration : BanubaUtilities.ImageConfigurationProtocol {
  @objc final public let image: UIKit.UIImage?
  @objc final public let tintColor: UIKit.UIColor?
  public init(image: UIKit.UIImage?, tintColor: UIKit.UIColor? = nil)
  @objc deinit
}
public protocol AnimatableView : UIKit.UIView {
  func start(completion: @escaping (Swift.Bool) -> Swift.Void)
  func stop()
}
public protocol CountdownTimerAnimatableView : BanubaUtilities.AnimatableView {
  var countdownDigit: Swift.Int { get set }
}
public protocol ProgressAnimatableView : UIKit.UIView {
  var progress: Swift.Float { get set }
}
@objc public protocol AppStateObserverDelegate {
  @objc func applicationWillResignActive(_ appStateObserver: BanubaUtilities.AppStateObserver)
  @objc func applicationDidBecomeActive(_ appStateObserver: BanubaUtilities.AppStateObserver)
  @objc optional func applicationWillEnterForeground(_ appStateObserver: BanubaUtilities.AppStateObserver)
  @objc optional func applicationWillTerminateNotification(_ appStateObserver: BanubaUtilities.AppStateObserver)
  @objc optional func applicationDidEnterBackgroundNotification(_ appStateObserver: BanubaUtilities.AppStateObserver)
}
@_inheritsConvenienceInitializers @objc public class AppStateObserver : ObjectiveC.NSObject {
  weak public var delegate: (any BanubaUtilities.AppStateObserverDelegate)?
  public var appWillResignActive: Swift.Bool {
    get
  }
  @objc override dynamic public init()
  convenience public init(delegate: (any BanubaUtilities.AppStateObserverDelegate)?)
  @objc deinit
}
extension BanubaUtilities.AppStateObserver {
  public func subscribeToNotifications()
  public func unsubscribeFromNotifications()
  @objc dynamic public func handleApplicationWillResignActiveNotification()
  @objc dynamic public func handleApplicationDidBecomeActiveNotification()
  @objc dynamic public func handleWillEnterForegroundNotification()
  @objc dynamic public func handleWillTerminateNotification()
  @objc dynamic public func handleDidEnterBackgroundNotification()
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func applyConfiguration(_ configuration: BanubaUtilities.BackgroundConfiguration)
}
public protocol PlayerStateStorable {
  var playerState: Swift.Bool { get set }
}
public protocol ImageTextButtonConfigurationProtocol {
  var imageConfiguration: (any BanubaUtilities.ImageConfigurationProtocol)? { get set }
  var selectedImageConfiguration: (any BanubaUtilities.ImageConfigurationProtocol)? { get set }
  var style: BanubaUtilities.TextConfiguration? { get set }
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func embed(toView view: UIKit.UIView, topOffset: CoreFoundation.CGFloat = .zero, leftOffset: CoreFoundation.CGFloat = .zero, rightOffset: CoreFoundation.CGFloat = .zero, bottomOffset: CoreFoundation.CGFloat = .zero, forceLayoutPass: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency public func embedUnspecifiedSemanticContent(toView view: UIKit.UIView, topOffset: CoreFoundation.CGFloat = .zero, leadingOffset: CoreFoundation.CGFloat = .zero, trailingOffset: CoreFoundation.CGFloat = .zero, bottomOffset: CoreFoundation.CGFloat = .zero, forceLayoutPass: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency public func unembed()
}
public struct ToastConfiguration {
  public var kern: Swift.Double
  public var font: UIKit.UIFont
  public var cornerRadius: CoreFoundation.CGFloat
  public var textColor: UIKit.UIColor
  public var backgroundColor: UIKit.UIColor
  public var borderWidth: CoreFoundation.CGFloat
  public var borderColor: UIKit.UIColor
  public var contentInsets: UIKit.UIEdgeInsets
  public var insets: UIKit.UIEdgeInsets
  public var icon: (any BanubaUtilities.ImageConfigurationProtocol)?
  public init(kern: Swift.Double, font: UIKit.UIFont, cornerRadius: CoreFoundation.CGFloat, textColor: UIKit.UIColor = .white, backgroundColor: UIKit.UIColor = .black, borderWidth: CoreFoundation.CGFloat = .zero, borderColor: UIKit.UIColor = .clear, contentInsets: UIKit.UIEdgeInsets = UIEdgeInsets(
      top: 15.0,
      left: 15.0,
      bottom: 15.0,
      right: 15.0
    ), insets: UIKit.UIEdgeInsets = UIEdgeInsets(
      top: 70.0,
      left: 16.0,
      bottom: .zero,
      right: 16.0
    ), icon: (any BanubaUtilities.ImageConfigurationProtocol)? = nil)
}
extension BanubaUtilities.ToastConfiguration {
  public static var `default`: BanubaUtilities.ToastConfiguration {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class NibView : UIKit.UIView, BanubaUtilities.NibLoadable {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency open func commonInit()
  @objc deinit
}
public struct GalleryLayoutConfiguration {
  public var numberOfItemsPerRow: Swift.Int
  public var interitemSpacing: CoreFoundation.CGFloat
  public var edgeInsets: UIKit.UIEdgeInsets
  public init(numberOfItemsPerRow: Swift.Int, interitemSpacing: CoreFoundation.CGFloat, edgeInsets: UIKit.UIEdgeInsets)
}
public protocol ReusableView : AnyObject {
}
extension BanubaUtilities.ReusableView {
  public static var reuseIdentifier: Swift.String {
    get
  }
}
public struct BackButtonConfiguration {
  public var imageConfiguration: any BanubaUtilities.ImageConfigurationProtocol
  public var selectedImageConfiguration: (any BanubaUtilities.ImageConfigurationProtocol)?
  public var position: BanubaUtilities.BackButtonConfiguration.Position?
  public var menuActions: [BanubaUtilities.PopoverAlertViewController.ActionType]
  @frozen public enum Position {
    case left
    case right
    public static func == (a: BanubaUtilities.BackButtonConfiguration.Position, b: BanubaUtilities.BackButtonConfiguration.Position) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(imageConfiguration: any BanubaUtilities.ImageConfigurationProtocol, selectedImageConfiguration: (any BanubaUtilities.ImageConfigurationProtocol)? = nil, position: BanubaUtilities.BackButtonConfiguration.Position? = nil, menuActions: [BanubaUtilities.PopoverAlertViewController.ActionType] = [])
}
public enum DrawableFigure : Swift.String, Swift.Codable {
  case circle
  case square
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public class AudioServiceItem : BanubaUtilities.AudioItem {
  final public let uuid: Foundation.UUID
  final public let url: Foundation.URL
  final public let coverURL: Foundation.URL?
  public var title: Swift.String?
  public var additionalTitle: Swift.String?
  public var isEditable: Swift.Bool
  public var timeRange: CoreMedia.CMTimeRange?
  public init(uuid: Foundation.UUID, url: Foundation.URL, coverURL: Foundation.URL?, title: Swift.String?, additionalTitle: Swift.String?, isEditable: Swift.Bool, timeRange: CoreMedia.CMTimeRange? = nil)
  @objc deinit
}
public protocol AudioPlayerDelegate : AnyObject {
  func playerPlaysFrameAtTime(_ time: Foundation.TimeInterval)
  func didEndPlaying()
}
public protocol AudioServicing {
  var player: AVFAudio.AVAudioPlayer? { get set }
  var delegate: (any BanubaUtilities.AudioPlayerDelegate)? { get set }
  var rate: Swift.Float { get set }
  var currentAudio: BanubaUtilities.AudioServiceItem? { get }
  var duration: Foundation.TimeInterval? { get }
  func autoRepeat(repeat: Swift.Bool, delay: Swift.Double)
  func seekToStart()
  func seekToStart(isEnabled: Swift.Bool)
  func seek(to: Foundation.TimeInterval)
  func load(item: BanubaUtilities.AudioServiceItem) throws
  func unload(shouldRemoveAudioFile: Swift.Bool)
  func toggle()
  func play()
  func pause()
  func setRate(_ rate: Swift.Float)
  func setDelegate(_ delegate: any BanubaUtilities.AudioPlayerDelegate)
  func changeVolume(volume: Swift.Float)
  func createAudioDirectory()
}
extension BanubaUtilities.AudioServicing {
  public func unload()
}
@objc @_inheritsConvenienceInitializers public class AudioService : ObjectiveC.NSObject, BanubaUtilities.AudioServicing {
  weak public var delegate: (any BanubaUtilities.AudioPlayerDelegate)?
  public var currentAudio: BanubaUtilities.AudioServiceItem?
  public var player: AVFAudio.AVAudioPlayer?
  public var duration: Foundation.TimeInterval? {
    get
  }
  public var playingTimeRange: CoreMedia.CMTimeRange?
  public var rate: Swift.Float {
    get
    set
  }
  public func autoRepeat(repeat: Swift.Bool)
  public func autoRepeat(repeat: Swift.Bool, delay: Swift.Double = .zero)
  public func seekToStart(isEnabled: Swift.Bool)
  public func createAudioDirectory()
  public func setRate(_ rate: Swift.Float)
  public func changeVolume(volume: Swift.Float)
  public func load(item: BanubaUtilities.AudioServiceItem) throws
  public func load(trackUrl: Foundation.URL) throws
  public func unload(shouldRemoveAudioFile: Swift.Bool = true)
  public func toggle()
  public func play()
  public func pause()
  public func seekToStart()
  public func seek(to: Foundation.TimeInterval)
  public func setDelegate(_ delegate: any BanubaUtilities.AudioPlayerDelegate)
  @objc override dynamic public init()
  @objc deinit
}
extension BanubaUtilities.AudioService : AVFAudio.AVAudioPlayerDelegate {
  @objc dynamic public func audioPlayerDidFinishPlaying(_ player: AVFAudio.AVAudioPlayer, successfully flag: Swift.Bool)
}
extension BanubaUtilities.AudioServicing {
  public var musicTrack: BanubaUtilities.MediaTrack? {
    get
  }
}
@objc public enum GalleryItemType : Swift.Int {
  case photo
  case video
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol GalleryItem : ObjectiveC.NSObjectProtocol {
  @objc var urlAsset: AVFoundation.AVURLAsset? { get }
  @objc var preview: UIKit.UIImage? { get set }
  @objc var duration: Foundation.TimeInterval { get }
  @objc var type: BanubaUtilities.GalleryItemType { get }
  @objc func requestPreview(size: CoreFoundation.CGSize, synchronously: Swift.Bool, handler: @escaping (UIKit.UIImage?) -> Swift.Void)
  @objc func requestPhoto(size: CoreFoundation.CGSize, progressHandler: ((Swift.Double) -> (Swift.Bool))?, handler: @escaping (UIKit.UIImage?, (any Swift.Error)?) -> Swift.Void)
  @objc func requestAVURLAsset(progressHandler: ((Swift.Double) -> (Swift.Bool))?, handler: @escaping (AVFoundation.AVURLAsset?, (any Swift.Error)?) -> Swift.Void)
  @objc func requestAVPlayerItem(progressHandler: ((Swift.Double) -> (Swift.Bool))?, handler: @escaping (AVFoundation.AVPlayerItem?, (any Swift.Error)?) -> Swift.Void)
}
@objc open class BanubaGalleryItem : ObjectiveC.NSObject, BanubaUtilities.GalleryItem {
  public static let defaultPreviewSize: CoreFoundation.CGSize
  final public let asset: Photos.PHAsset
  final public let videoResolution: BanubaUtilities.VideoResolution
  @objc public var preview: UIKit.UIImage?
  @objc public var duration: Foundation.TimeInterval {
    @objc get
  }
  @objc public var urlAsset: AVFoundation.AVURLAsset? {
    get
  }
  @objc public var type: BanubaUtilities.GalleryItemType {
    @objc get
  }
  public init(asset: Photos.PHAsset, videoResolution: BanubaUtilities.VideoResolution)
  @objc open func requestAVURLAsset(progressHandler: ((Swift.Double) -> (Swift.Bool))?, handler: @escaping (AVFoundation.AVURLAsset?, (any Swift.Error)?) -> Swift.Void)
  @objc open func requestAVPlayerItem(progressHandler: ((Swift.Double) -> (Swift.Bool))?, handler: @escaping (AVFoundation.AVPlayerItem?, (any Swift.Error)?) -> Swift.Void)
  @objc open func requestPreview(size: CoreFoundation.CGSize = BanubaGalleryItem.defaultPreviewSize, synchronously: Swift.Bool, handler: @escaping (UIKit.UIImage?) -> Swift.Void)
  @objc open func requestPhoto(size: CoreFoundation.CGSize, progressHandler: ((Swift.Double) -> (Swift.Bool))?, handler: @escaping (UIKit.UIImage?, (any Swift.Error)?) -> Swift.Void)
  @objc deinit
}
extension BanubaUtilities.BanubaGalleryItem {
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
}
@objc public protocol GalleryViewControllerFactory : ObjectiveC.NSObjectProtocol {
  @objc func makeGalleryViewController(withConfiguration configuration: BanubaUtilities.GalleryConfiguration, albumsConfiguration: BanubaUtilities.AlbumsConfiguration, selectionBehaviour: BanubaUtilities.GallerySelectionBehaviour) -> BanubaUtilities.GalleryViewController
}
public struct AudioPartSelectionViewConfiguration {
  public var titleText: Swift.String
  public var backgroundColor: UIKit.UIColor
  public var textColor: UIKit.UIColor
  public var audioWaveColor: UIKit.UIColor
  public var playingAudioWaveColor: UIKit.UIColor
  public var maximumAudioRangeBackgroundColor: UIKit.UIColor
  public var maximumAudioRangeBackgroundBorderColor: UIKit.UIColor
  public var maximumAudioRangeBackgroundBorderWidth: CoreFoundation.CGFloat
  public var amplitudeBarWidth: CoreFoundation.CGFloat
  public var amplitudeBarsSpacing: CoreFoundation.CGFloat
  public var isTimeRangeLabelCentered: Swift.Bool
  public static var musicLibraryDark: BanubaUtilities.AudioPartSelectionViewConfiguration {
    get
  }
  public static var musicLibraryLight: BanubaUtilities.AudioPartSelectionViewConfiguration {
    get
  }
  public static var soundstripe: BanubaUtilities.AudioPartSelectionViewConfiguration {
    get
  }
  public static var audioAdjust: BanubaUtilities.AudioPartSelectionViewConfiguration {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class AudioPartSelectionView : UIKit.UIView, UIKit.UIScrollViewDelegate {
  @_Concurrency.MainActor @preconcurrency final public var didScrollHandler: ((CoreMedia.CMTimeRange) -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override final public func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency final public func set(audioStartOffset: Foundation.TimeInterval = .zero, audioDuration: Foundation.TimeInterval, videoDuration: Foundation.TimeInterval)
  @_Concurrency.MainActor @preconcurrency final public func set(playbackProgress: Swift.Double)
  @_Concurrency.MainActor @preconcurrency final public func showAudioAmplitude(samples: [Swift.Float])
  @_Concurrency.MainActor @preconcurrency final public func apply(configuration: BanubaUtilities.AudioPartSelectionViewConfiguration)
  @_Concurrency.MainActor @preconcurrency final public func stopSelectionAnimationIfNeeded()
  @_Concurrency.MainActor @preconcurrency @objc final public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc final public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc final public func scrollViewDidEndDragging(_ scrollView: UIKit.UIScrollView, willDecelerate decelerate: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc final public func scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc final public func scrollViewWillBeginDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency final public func setPlayedRangeOverlayViewHidden(_ isHidden: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency final public func updatePlayedRangeOverlayViewLayer(completion: (() -> Swift.Void)? = nil)
  @objc deinit
}
extension Swift.Array where Element : Swift.Hashable {
  public func uniqued() -> [Element]
}
extension Swift.Error {
  public var errorMessage: Swift.String {
    get
  }
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func dropShadow(_ offset: CoreFoundation.CGSize = CGSize(width: 0, height: 1), blur: CoreFoundation.CGFloat = 1, opacity: Swift.Float = 1)
  @_Concurrency.MainActor @preconcurrency public func dropShadow(configuration: BanubaUtilities.ShadowConfiguration)
}
@objc public class SmallActivityIndicatorConfiguration : ObjectiveC.NSObject {
  @objc public enum GradientTypeAdapter : Swift.Int {
    case color
    case image
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public class GradientType : ObjectiveC.NSObject {
    public var type: BanubaUtilities.SmallActivityIndicatorConfiguration.GradientTypeAdapter
    public var color: BanubaUtilities.SmallActivityIndicatorConfiguration.GradientColorConfiguration?
    public var image: (any BanubaUtilities.ImageConfigurationProtocol)?
    public init(type: BanubaUtilities.SmallActivityIndicatorConfiguration.GradientTypeAdapter, color: BanubaUtilities.SmallActivityIndicatorConfiguration.GradientColorConfiguration?, image: (any BanubaUtilities.ImageConfigurationProtocol)?)
    @objc deinit
  }
  @objc public class GradientColorConfiguration : ObjectiveC.NSObject {
    public var angle: CoreFoundation.CGFloat
    public var colors: [CoreGraphics.CGColor]
    public init(angle: CoreFoundation.CGFloat, colors: [CoreGraphics.CGColor])
    @objc deinit
  }
  public var gradientType: BanubaUtilities.SmallActivityIndicatorConfiguration.GradientType
  public var activityLineWidth: CoreFoundation.CGFloat
  public init(gradientType: BanubaUtilities.SmallActivityIndicatorConfiguration.GradientType, activityLineWidth: CoreFoundation.CGFloat)
  @objc deinit
}
extension BanubaUtilities.SmallActivityIndicatorConfiguration.GradientType {
  @objc public static func color(_ color: BanubaUtilities.SmallActivityIndicatorConfiguration.GradientColorConfiguration) -> BanubaUtilities.SmallActivityIndicatorConfiguration.GradientType
  @objc public static func image(_ image: any BanubaUtilities.ImageConfigurationProtocol) -> BanubaUtilities.SmallActivityIndicatorConfiguration.GradientType
}
public struct AutoCutGalleryConfiguration {
  public let normalApplyAutoCutButtonConfiguration: BanubaUtilities.ApplyAutoCutButtonConfiguration
  public let disabledApplyAutoCutButtonConfiguration: BanubaUtilities.ApplyAutoCutButtonConfiguration
  public let normalNextButtonConfiguration: BanubaUtilities.GalleryNextButtonConfiguration
  public let disabledNextButtonConfiguration: BanubaUtilities.GalleryNextButtonConfiguration
  public let maximumDurationOfAutoCutSourceVideos: Foundation.TimeInterval
  public init(normalApplyAutoCutButtonConfiguration: BanubaUtilities.ApplyAutoCutButtonConfiguration, disabledApplyAutoCutButtonConfiguration: BanubaUtilities.ApplyAutoCutButtonConfiguration, normalNextButtonConfiguration: BanubaUtilities.GalleryNextButtonConfiguration, disabledNextButtonConfiguration: BanubaUtilities.GalleryNextButtonConfiguration, maximumDurationOfAutoCutSourceVideos: Foundation.TimeInterval)
}
public struct ApplyAutoCutButtonConfiguration {
  public let borderColor: UIKit.UIColor
  public let borderWidth: CoreFoundation.CGFloat
  public let backgroundColor: UIKit.UIColor
  public let iconConfiguration: any BanubaUtilities.ImageConfigurationProtocol
  public let textConfiguration: BanubaUtilities.TextConfiguration
  public init(borderColor: UIKit.UIColor, borderWidth: CoreFoundation.CGFloat = 1.0, backgroundColor: UIKit.UIColor = .clear, iconConfiguration: any BanubaUtilities.ImageConfigurationProtocol, textConfiguration: BanubaUtilities.TextConfiguration)
}
public struct GalleryNextButtonConfiguration {
  public let textConfiguration: BanubaUtilities.TextConfiguration
  public let backgroundColor: UIKit.UIColor
  public init(textConfiguration: BanubaUtilities.TextConfiguration, backgroundColor: UIKit.UIColor)
}
public enum VideoResolution : Swift.String, Swift.Codable {
  case uhd3840x2160
  case qhd2560x1440
  case hd1920x1080
  case hd1280x720
  case md960x540
  case default854x480
  public var isFullHDEnabled: Swift.Bool {
    get
  }
  public var сaptureSessionPreset: AVFoundation.AVCaptureSession.Preset {
    get
  }
  public var assetExportPreset: Swift.String {
    get
  }
  public var size: CoreFoundation.CGSize {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum CameraVideoResolution : Swift.String, Swift.Codable {
  case auto
  case vga854x480
  case hd1280x720
  case hd1920x1080
  public var сaptureSessionPreset: AVFoundation.AVCaptureSession.Preset? {
    get
  }
  public var size: CoreFoundation.CGSize? {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct VideoResolutionConfiguration : Swift.Codable {
  public var `default`: BanubaUtilities.VideoResolution
  public var cameraVideoResolution: BanubaUtilities.CameraVideoResolution
  public let resolutions: [BanubaUtilities.DeviceModel : BanubaUtilities.VideoResolution]
  public let thumbnailHeights: [BanubaUtilities.DeviceModel : CoreFoundation.CGFloat]
  public let defaultThumbnailHeight: CoreFoundation.CGFloat
  public var current: BanubaUtilities.VideoResolution {
    get
  }
  public var currentThumbnailHeight: CoreFoundation.CGFloat {
    get
  }
  public init(default: BanubaUtilities.VideoResolution, cameraVideoResolution: BanubaUtilities.CameraVideoResolution = .auto, resolutions: [BanubaUtilities.DeviceModel : BanubaUtilities.VideoResolution], thumbnailHeights: [BanubaUtilities.DeviceModel : CoreFoundation.CGFloat], defaultThumbnailHeight: CoreFoundation.CGFloat)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension AVFoundation.AVCaptureSession.Preset {
  public mutating func downgrade()
}
public struct BorderButtonConfiguration {
  public var borderWidth: CoreFoundation.CGFloat
  public var borderColor: CoreGraphics.CGColor
  public init(borderWidth: CoreFoundation.CGFloat, borderColor: CoreGraphics.CGColor)
}
public struct RoundedButtonConfiguration {
  public var textConfiguration: BanubaUtilities.TextConfiguration?
  public var borderWidth: CoreFoundation.CGFloat?
  public var borderColor: CoreGraphics.CGColor?
  public var cornerRadius: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var titleSpacing: CoreFoundation.CGFloat?
  public init(textConfiguration: BanubaUtilities.TextConfiguration?, cornerRadius: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, borderWidth: CoreFoundation.CGFloat? = nil, borderColor: CoreGraphics.CGColor? = nil, width: CoreFoundation.CGFloat = 70.0, height: CoreFoundation.CGFloat = 30.0)
}
extension UIKit.UIImageView {
  @_Concurrency.MainActor @preconcurrency public func applyConfiguration(_ imageConfiguration: (any BanubaUtilities.ImageConfigurationProtocol)?)
}
extension Swift.Error {
  public var isCancelled: Swift.Bool {
    get
  }
  public var isNetworkUnavailable: Swift.Bool {
    get
  }
}
extension Foundation.NSError {
  public static func makeCancelledError(domain: Swift.String) -> Foundation.NSError
}
extension CoreFoundation.CGSize {
  public func swap() -> CoreFoundation.CGSize
}
public class PreviewExtractor {
  final public let asset: AVFoundation.AVAsset
  final public let thumbnailHeight: CoreFoundation.CGFloat
  final public let imageGenerator: AVFoundation.AVAssetImageGenerator
  public init(asset: AVFoundation.AVAsset, thumbnailHeight: CoreFoundation.CGFloat)
  @objc deinit
  public func extractPreview(at time: CoreMedia.CMTime) -> UIKit.UIImage?
  public func extractPreview(at time: CoreMedia.CMTime) async -> UIKit.UIImage?
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func roundCorners(corners: UIKit.UIRectCorner, radius: CoreFoundation.CGFloat)
  @_Concurrency.MainActor @preconcurrency public func roundCorners(cornerMask: QuartzCore.CACornerMask, radius: CoreFoundation.CGFloat)
  @_Concurrency.MainActor @preconcurrency public func roundCorners(radius: CoreFoundation.CGFloat)
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency public class func loadFromNib() -> Self
}
extension CoreMedia.CMTime : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public var keyboardLayoutAnchor: UIKit.UILayoutGuide {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var keyboardLayoutAnchorNoSafeArea: UIKit.UILayoutGuide {
    get
  }
}
@objc @_Concurrency.MainActor @preconcurrency open class KeyboardLayoutGuide : UIKit.UILayoutGuide {
  @_Concurrency.MainActor @preconcurrency public var usesSafeArea: Swift.Bool {
    get
    set
  }
  @available(*, unavailable)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency public init(notificationCenter: Foundation.NotificationCenter = NotificationCenter.default)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class VideoEditorActivityIndicator : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public var configuration: BanubaUtilities.SmallActivityIndicatorConfiguration? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var bounds: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency public func startAnimating()
  @_Concurrency.MainActor @preconcurrency public func stopAnimating()
  @objc deinit
}
public enum OverlayPopoverActionsPosition {
  case bottomLeft(_: CoreFoundation.CGPoint)
  case topLeft(_: CoreFoundation.CGPoint)
  case topRight(_: CoreFoundation.CGPoint)
  case bottomRight(_: CoreFoundation.CGPoint)
  case center
}
public struct PopoverAlertViewConfiguration {
  public var mainBackgroundColor: UIKit.UIColor
  public var actionsViewBackgroundColor: UIKit.UIColor
  public var cornerRadius: CoreFoundation.CGFloat
  public var actionCellHeight: CoreFoundation.CGFloat
  public var hideAnimated: Swift.Bool
  public static var `default`: BanubaUtilities.PopoverAlertViewConfiguration {
    get
  }
  public init(mainBackgroundColor: UIKit.UIColor, actionsViewBackgroundColor: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat, actionCellHeight: CoreFoundation.CGFloat, hideAnimated: Swift.Bool)
}
public struct OverlayPopoverActionConfiguration {
  public init(leftImage: (any BanubaUtilities.ImageConfigurationProtocol)?, rightImage: (any BanubaUtilities.ImageConfigurationProtocol)?, title: BanubaUtilities.TextConfiguration, titleImageInset: CoreFoundation.CGFloat)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class PopoverAlertViewController : UIKit.UIViewController, BanubaUtilities.NibLoadable {
  public enum ActionType {
    case edit(BanubaUtilities.OverlayPopoverActionConfiguration)
    case delete(BanubaUtilities.OverlayPopoverActionConfiguration)
    case discardChanges(BanubaUtilities.OverlayPopoverActionConfiguration)
    case updateDraft(BanubaUtilities.OverlayPopoverActionConfiguration)
  }
  @_Concurrency.MainActor @preconcurrency public var configuration: BanubaUtilities.PopoverAlertViewConfiguration
  @_Concurrency.MainActor @preconcurrency public var actions: [BanubaUtilities.PopoverAlertViewController.ActionType]
  @_Concurrency.MainActor @preconcurrency public var actionsPosition: BanubaUtilities.OverlayPopoverActionsPosition
  @_Concurrency.MainActor @preconcurrency public var resultCompletion: ((BanubaUtilities.PopoverAlertViewController.ActionType) -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension BanubaUtilities.PopoverAlertViewController : UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldReceive touch: UIKit.UITouch) -> Swift.Bool
}
public class ToastPresenter {
  public init(configuration: BanubaUtilities.ToastConfiguration, toastLifeTime: Foundation.TimeInterval? = nil)
  @objc deinit
  public func showToast(message: Swift.String)
}
extension Foundation.NSNotification.Name {
  public static let videoEditorPlayerCurrentTimeChanged: Foundation.Notification.Name
}
public protocol VideoEditorPlayable : AnyObject {
  var isPlaying: Swift.Bool { get }
  var playerItem: AVFoundation.AVPlayerItem? { get }
  var avPlayer: AVFoundation.AVPlayer { get }
  var currentTime: CoreMedia.CMTime { get }
  var videoDuration: CoreMedia.CMTime { get }
  var playingRange: CoreMedia.CMTimeRange { get set }
  var isMuted: Swift.Bool { get set }
  var audioMix: AVFoundation.AVAudioMix? { get set }
  var playerDelegate: (any BanubaUtilities.VideoEditorPlayerDelegate)? { get set }
  func play(loop: Swift.Bool, fixedSpeed: Swift.Bool)
  func play(loop: Swift.Bool, fixedSpeed: Swift.Bool, range: CoreMedia.CMTimeRange)
  func pause()
  func seek(to time: CoreMedia.CMTime)
  func smoothlySeek(to time: CoreMedia.CMTime)
  func seek(to time: CoreMedia.CMTime, completion: @escaping (_ isFinished: Swift.Bool) -> Swift.Void)
  func reloadPreview(shouldAutoStart: Swift.Bool)
}
public protocol VideoEditorPlayerDelegate : AnyObject {
  func playerPlaysFrame(_ player: any BanubaUtilities.VideoEditorPlayable, atTime time: CoreMedia.CMTime)
  func playerDidEndPlaying(_ player: any BanubaUtilities.VideoEditorPlayable)
}
public protocol NibLoadable : AnyObject {
  static var nib: UIKit.UINib { get }
}
extension BanubaUtilities.NibLoadable {
  public static var nib: UIKit.UINib {
    get
  }
}
extension BanubaUtilities.NibLoadable where Self : UIKit.UIView {
  public static func loadFromNib() -> Self
}
@objc public class TextConfiguration : ObjectiveC.NSObject {
  public var kern: Swift.Double
  public var font: UIKit.UIFont
  public var color: UIKit.UIColor
  public var alignment: UIKit.NSTextAlignment
  public var text: Swift.String?
  public var shadow: BanubaUtilities.TextShadowConfiguration?
  public var lineBreakMode: UIKit.NSLineBreakMode
  public init(kern: Swift.Double = 0, font: UIKit.UIFont, color: UIKit.UIColor, alignment: UIKit.NSTextAlignment = .center, text: Swift.String? = nil, shadow: BanubaUtilities.TextShadowConfiguration? = nil, lineBreakMode: UIKit.NSLineBreakMode = .byWordWrapping)
  @objc override dynamic public func copy() -> Any
  public var attributes: [Foundation.NSAttributedString.Key : Any] {
    get
  }
  @objc deinit
}
public struct TextShadowConfiguration {
  public var shadowColor: UIKit.UIColor
  public var shadowOffset: CoreFoundation.CGSize
  public var shadowBlurRadius: CoreFoundation.CGFloat
  public init(shadowColor: UIKit.UIColor = UIColor.black.withAlphaComponent(0.4), shadowOffset: CoreFoundation.CGSize = CGSize(width: 0, height: 1), shadowBlurRadius: CoreFoundation.CGFloat = 2.0)
  public func shadow() -> UIKit.NSShadow
}
public struct ShadowConfiguration {
  public var color: UIKit.UIColor
  public var offset: CoreFoundation.CGSize
  public var blurRadius: CoreFoundation.CGFloat
  public var opacity: Swift.Float
  public init(color: UIKit.UIColor, offset: CoreFoundation.CGSize, blurRadius: CoreFoundation.CGFloat, opacity: Swift.Float)
  public var shadow: UIKit.NSShadow {
    get
  }
}
extension BanubaUtilities.AlertViewController.ButtonType : Swift.Equatable {}
extension BanubaUtilities.AlertViewController.ButtonType : Swift.Hashable {}
extension BanubaUtilities.AspectRatio : Swift.Equatable {}
extension BanubaUtilities.AspectRatio : Swift.Hashable {}
extension BanubaUtilities.AspectRatio : Swift.RawRepresentable {}
extension BanubaUtilities.SlideInPresentationManager : Swift.Sendable {}
extension BanubaUtilities.Connection : Swift.Equatable {}
extension BanubaUtilities.Connection : Swift.Hashable {}
extension BanubaUtilities.TTSegmentedControl.TitleDistribution : Swift.Equatable {}
extension BanubaUtilities.TTSegmentedControl.TitleDistribution : Swift.Hashable {}
extension BanubaUtilities.TTSegmentedControl.SelectionViewFillType : Swift.Equatable {}
extension BanubaUtilities.TTSegmentedControl.SelectionViewFillType : Swift.Hashable {}
extension BanubaUtilities.CacheType : Swift.Equatable {}
extension BanubaUtilities.CacheType : Swift.Hashable {}
extension BanubaUtilities.ContentMode : Swift.Equatable {}
extension BanubaUtilities.ContentMode : Swift.Hashable {}
extension BanubaUtilities.ImageFormat : Swift.Equatable {}
extension BanubaUtilities.ImageFormat : Swift.Hashable {}
extension BanubaUtilities.DeviceModel : Swift.Equatable {}
extension BanubaUtilities.DeviceModel : Swift.Hashable {}
extension BanubaUtilities.DeviceModel : Swift.RawRepresentable {}
extension BanubaUtilities.TransitionType : Swift.Equatable {}
extension BanubaUtilities.TransitionType : Swift.Hashable {}
extension BanubaUtilities.TransitionType : Swift.RawRepresentable {}
extension BanubaUtilities.TTSwiftUISegmentedControl : Swift.Sendable {}
extension BanubaUtilities.GalleryItemConfiguration.DurationLabelAlignment : Swift.Equatable {}
extension BanubaUtilities.GalleryItemConfiguration.DurationLabelAlignment : Swift.Hashable {}
extension BanubaUtilities.GalleryItemConfiguration.SelectedOverlay : Swift.Sendable {}
extension BanubaUtilities.BackgroundMode : Swift.Sendable {}
extension BanubaUtilities.TTSegmentedControlTitle.ImagePosition : Swift.Equatable {}
extension BanubaUtilities.TTSegmentedControlTitle.ImagePosition : Swift.Hashable {}
extension BanubaUtilities.GalleryMediaType : Swift.Equatable {}
extension BanubaUtilities.GalleryMediaType : Swift.Hashable {}
extension BanubaUtilities.GalleryMediaType : Swift.RawRepresentable {}
extension BanubaUtilities.FileExtension.Video : Swift.Equatable {}
extension BanubaUtilities.FileExtension.Video : Swift.Hashable {}
extension BanubaUtilities.FileExtension.Video : Swift.RawRepresentable {}
extension BanubaUtilities.BackButtonConfiguration.Position : Swift.Equatable {}
extension BanubaUtilities.BackButtonConfiguration.Position : Swift.Hashable {}
extension BanubaUtilities.BackButtonConfiguration.Position : Swift.Sendable {}
extension BanubaUtilities.BackButtonConfiguration.Position : Swift.BitwiseCopyable {}
extension BanubaUtilities.DrawableFigure : Swift.Equatable {}
extension BanubaUtilities.DrawableFigure : Swift.Hashable {}
extension BanubaUtilities.DrawableFigure : Swift.RawRepresentable {}
extension BanubaUtilities.GalleryItemType : Swift.Equatable {}
extension BanubaUtilities.GalleryItemType : Swift.Hashable {}
extension BanubaUtilities.GalleryItemType : Swift.RawRepresentable {}
extension BanubaUtilities.SmallActivityIndicatorConfiguration.GradientTypeAdapter : Swift.Equatable {}
extension BanubaUtilities.SmallActivityIndicatorConfiguration.GradientTypeAdapter : Swift.Hashable {}
extension BanubaUtilities.SmallActivityIndicatorConfiguration.GradientTypeAdapter : Swift.RawRepresentable {}
extension BanubaUtilities.VideoResolution : Swift.Equatable {}
extension BanubaUtilities.VideoResolution : Swift.Hashable {}
extension BanubaUtilities.VideoResolution : Swift.RawRepresentable {}
extension BanubaUtilities.CameraVideoResolution : Swift.Equatable {}
extension BanubaUtilities.CameraVideoResolution : Swift.Hashable {}
extension BanubaUtilities.CameraVideoResolution : Swift.RawRepresentable {}
